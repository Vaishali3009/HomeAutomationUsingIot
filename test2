package com.rbs.bdd.infrastructure.entity;
import jakarta.persistence.*;
import lombok.*;

import java.util.UUID;

@Entity
@Table(name = "customer_record")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CustomerData {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private UUID id;

    @Column(name = "account_no", nullable = false, unique = true)
    private String accountNo;

    @Column(name = "customer_prefix")
    private String prefixType;

    @Column(name = "customer_first_name")
    private String firstName;

    @Column(name = "customer_last_name")
    private String lastName;

    @Column(name = "account_type")
    private String accountType;


}



package com.rbs.bdd.infrastructure.repository;

import com.rbs.bdd.infrastructure.entity.CustomerData;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository public interface CustomerRepository extends JpaRepository<CustomerData, Long> {

    Optional<CustomerData> findByAccountNo(String accountNo);
}

package com.rbs.bdd.infrastructure.soap.api;

import com.rbs.bdd.application.port.in.CustomerRetrievalPort;
import com.rbs.bdd.application.port.in.PaymentValidationPort;

import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.RetrievePrimaryCustomerForArrRequest;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;
import org.springframework.ws.server.endpoint.annotation.ResponsePayload;

import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_ACCOUNT_VALIDATION;
import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL;


/**
 * SOAP endpoint adapter class for handling the `validateArrangementForPayment` operation.
 * It uses Spring WS annotations to route incoming SOAP requests to the appropriate service layer.
 */
@Slf4j
@Endpoint
public class PaymentValidationSoapAdapter {

    /**Changes for the request*/


    private final PaymentValidationPort paymentValidationPort;
    private final CustomerRetrievalPort customerRetrievalPort;

    /**
     * Constructor-based injection of the orchestrator that handles business logic.
     *
     * @param paymentValidationPort the orchestrator service
     */
    public PaymentValidationSoapAdapter(PaymentValidationPort paymentValidationPort,CustomerRetrievalPort customerRetrievalPort) {
        this.paymentValidationPort = paymentValidationPort;
        this.customerRetrievalPort = customerRetrievalPort;
    }



    /**
     * Handles the `validateArrangementForPayment` SOAP request.
     * Delegates request processing to the orchestrator which modifies the response message directly.
     *
     * @param request the SOAP request payload
     * @param context the Spring WS message context
     */
    @PayloadRoot(namespace = NAMESPACE_URI_FOR_ACCOUNT_VALIDATION, localPart = "validateArrangementForPayment")
    @ResponsePayload
    public void validateArrangementForPayment(@RequestPayload ValidateArrangementForPaymentRequest request,
                                                MessageContext context) {
        log.info("validateArrangementForPayment is called");
        WebServiceMessage response = context.getResponse();
        paymentValidationPort.validateArrangementForPayment(request, response);
         }

    /**
     * Handles the `RetrieveCustomerRequest` SOAP request.
     * Delegates request processing to the orchestrator which modifies the response message directly.
     *
     * @param request the SOAP request payload
     * @param context the Spring WS message context
     */
    @PayloadRoot(namespace = NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL, localPart = "retrievePrimaryCustomerForArr")
    @ResponsePayload
    public void validateCustomerRetrieval(@RequestPayload RetrievePrimaryCustomerForArrRequest request,
                                              MessageContext context) {
        log.info("validateCustomerRetrieval is called");
        WebServiceMessage response = context.getResponse();

        customerRetrievalPort.validateCustomerRetrieval(request, response);
    }

}



package com.rbs.bdd.infrastructure.soap.interceptor;


import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.util.SoapInterceptorUtils;

import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import javax.xml.transform.TransformerException;
import java.io.IOException;
import java.io.InputStream;
import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_ACCOUNT_VALIDATION;
import static com.rbs.bdd.domain.enums.ServiceConstants.Paths.ACCOUNT_VALIDATION_SCHEMA_VALIDATION_ERROR_XML;


/**
 * Intercepts schema validation errors in SOAP requests and returns a custom SOAP fault response.
 * The response is based on a static XML file, with dynamic fields replaced using request data.
 */
@Slf4j
public class AccountSchemaValidationInterceptor extends PayloadValidatingInterceptor {

    @Override
    public boolean handleRequest(MessageContext messageContext, Object endpoint) throws IOException, TransformerException, SAXException {
        log.info(" Entered in handleRequest method");
        if (SoapInterceptorUtils.skipInterceptorIfNamespaceNotMatched(messageContext, NAMESPACE_URI_FOR_ACCOUNT_VALIDATION)) {
            return true;
        }
        return super.handleRequest(messageContext, endpoint);
    }


    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @param errors         the validation errors
     * @return false to prevent Spring WS from overriding with default fault
     */
    @Override
    public boolean handleRequestValidationErrors(MessageContext messageContext, SAXParseException[] errors) {
        log.error("Schema validation failed For Account Validation ");
        return SoapInterceptorUtils.handleSchemaValidationErrors(messageContext
                ,ACCOUNT_VALIDATION_SCHEMA_VALIDATION_ERROR_XML,"accountValidation");
    }



    /**
     * Retrieves static XML file from classpath. Can be overridden in tests.
     *
     * @param path the classpath location of the file
     * @return input stream for the XML file
     */
    protected InputStream getClassLoaderResource(String path) {
        return getClass().getClassLoader().getResourceAsStream(path);
    }

}


package com.rbs.bdd.infrastructure.soap.interceptor;



import com.rbs.bdd.util.SoapInterceptorUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import javax.xml.transform.TransformerException;
import java.io.IOException;
import java.io.InputStream;
import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL;
import static com.rbs.bdd.domain.enums.ServiceConstants.Paths.CUSTOMER_SCHEMA_VALIDATION_ERROR_XML;


/**
 * Intercepts schema validation errors in SOAP requests and returns a custom SOAP fault response.
 * The response is based on a static XML file, with dynamic fields replaced using request data.
 */
@Slf4j
public class CustomerSchemaValidationInterceptor extends PayloadValidatingInterceptor {




    @Override
    public boolean handleRequest(MessageContext messageContext, Object endpoint) throws IOException, TransformerException, SAXException {
        log.error("Entered in handleRequest ");

        if (SoapInterceptorUtils.skipInterceptorIfNamespaceNotMatched(messageContext, NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL)) {
            return true;
        }
        return super.handleRequest(messageContext, endpoint);
    }


    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @param errors         the validation errors
     * @return false to prevent Spring WS from overriding with default fault
     */
    @Override
    public boolean handleRequestValidationErrors(MessageContext messageContext, SAXParseException[] errors) {
        log.error("Schema validation failed. Entered in handleRequestValidationErrors method");
        return SoapInterceptorUtils.handleSchemaValidationErrors(messageContext,
                CUSTOMER_SCHEMA_VALIDATION_ERROR_XML,"customerRetrieval");
    }


    /**
     * Retrieves static XML file from classpath. Can be overridden in tests.
     *
     * @param path the classpath location of the file
     * @return input stream for the XML file
     */
    protected InputStream getClassLoaderResource(String path) {
        return getClass().getClassLoader().getResourceAsStream(path);
    }

}


package com.rbs.bdd.infrastructure.soap.interceptor;
import com.rbs.bdd.common.context.TransactionIdContext;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.stereotype.Component;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.server.EndpointInterceptor;
import org.springframework.ws.soap.SoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.StringReader;
import java.util.UUID;

@Component
@Slf4j
public class TransactionIdInterceptor implements EndpointInterceptor {

    @Override
    public boolean handleRequest(MessageContext messageContext, Object endpoint) {
        try {
            WebServiceMessage request = messageContext.getRequest();

            // Extract transactionId from request XML if present
            String transactionId = extractTransactionId(request);

            if (transactionId == null || transactionId.isEmpty()) {
                transactionId = UUID.randomUUID().toString();
            }

            TransactionIdContext.set(transactionId);

            // Add to logs
            MDC.put("transactionId", transactionId);  // If using Logback/SLF4J MDC

        } catch (Exception e) {
            // Fallback in case of error
            TransactionIdContext.set(UUID.randomUUID().toString());
        }
        return true;
    }

    @Override
    public boolean handleResponse(MessageContext messageContext, Object endpoint) {
        TransactionIdContext.clear();
        MDC.remove("transactionId");
        return true;
    }

    @Override
    public boolean handleFault(MessageContext messageContext, Object endpoint) {
        TransactionIdContext.clear();
        MDC.remove("transactionId");
        return true;
    }

    @Override
    public void afterCompletion(MessageContext messageContext, Object endpoint, Exception ex) {
        TransactionIdContext.clear();
        MDC.remove("transactionId");
    }

    private String extractTransactionId(WebServiceMessage message) {
        try {
            // Convert Source to String
            Source source = message.getPayloadSource();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.transform(source, new StreamResult(out));
            String xmlString = out.toString(); // Converts bytes to string

            // Parse XML
            Document document = DocumentBuilderFactory.newInstance()
                    .newDocumentBuilder()
                    .parse(new InputSource(new StringReader(xmlString)));

            NodeList nodes = document.getElementsByTagName("transactionId");
            if (nodes.getLength() > 0) {
                log.debug("transactionId found in request");
                return nodes.item(0).getTextContent();
            }

        } catch (Exception e) {
            log.warn("Failed to extract transactionId", e);
        }
        return null;
    }
}

package com.rbs.bdd.util;

import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.application.exception.XsdSchemaLoadingException;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;
import org.springframework.xml.xsd.XsdSchemaCollection;
import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.SYSTEM_ID;
import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.TAG_TRANSACTION_ID;
import static com.rbs.bdd.util.ValidationUtils.*;

@Slf4j
public class SoapInterceptorUtils {
    private SoapInterceptorUtils(){}
    private static final String PLACEHOLDER_TXN = "TXN_ID_PLACEHOLDER";
    private static final String PLACEHOLDER_RESPONSE = "RESPONSE_ID_PLACEHOLDER";

    /**
     * Retrieves the text content of a given tag from the request document.
     */
    public static String getValueFromRequest(Document doc, String tag) {
        NodeList list = doc.getElementsByTagNameNS("*", tag);
        return list.getLength() > 0 ? list.item(0).getTextContent() : null;
    }


    /**
     * Replaces a text node matching a placeholder with a new value.
     */
    public static void replaceTextNode(Document doc, String placeholder, String newValue) {
        NodeList nodes = doc.getElementsByTagNameNS("*", TAG_TRANSACTION_ID);
        for (int i = 0; i < nodes.getLength(); i++) {
            Node txn = nodes.item(i);
            if (placeholder.equals(txn.getTextContent())) {
                txn.setTextContent(newValue);
            }
        }
    }

    /**
     * Sends the final SOAP error response with HTTP 500.
     */
    public static void sendCustomSoapFault(Document errorDoc) throws TransformerException, IOException {
        log.info("Sending the sendCustomSoapFault ");
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,"");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,"");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(errorDoc), new StreamResult(out));
        HttpServletResponse servletResponse =
                ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getResponse();
        if (servletResponse != null && !servletResponse.isCommitted()) {
            servletResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            servletResponse.setContentType("text/xml;charset=UTF-8");
            servletResponse.getOutputStream().write(out.toByteArray());
            servletResponse.flushBuffer();}
    }

    /**
     * Creates a secure, namespace-aware {@link DocumentBuilderFactory}.
     * <p>
     * This method disables external entity processing to prevent XML External Entity (XXE)
     * attacks and other injection vulnerabilities.
     * @return configured {@link DocumentBuilderFactory} instance
     * @throws ParserConfigurationException if security features cannot be set
     */
    public static DocumentBuilder getSecureDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        return factory.newDocumentBuilder();
    }
    public static boolean skipInterceptorIfNamespaceNotMatched(MessageContext messageContext, String expectedNamespace) {
        try {
            log.error("Entered in skipInterceptorIfNamespaceNotMatched ");
            WebServiceMessage request = messageContext.getRequest();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            request.writeTo(out);
            String xml =out.toString();
            if (!xml.contains(expectedNamespace)) {
                return true;
            }
        } catch (Exception e) {
            log.error("Error in namespace filtering", e);
        }
        return false;
    }

    public static XsdSchemaCollection loadSchema(String path)
    {
        try {
            log.info("Entered in skipInterceptorIfNamespaceNotMatched ");
            CommonsXsdSchemaCollection xsd = new CommonsXsdSchemaCollection(
                    new ClassPathResource(path));
            xsd.setInline(true);
            return xsd;
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Failed to load XSD schema for SOAP validation", e);
        }
    }

    public static DefaultWsdl11Definition buildWsdlDefinition( String portType, String namespace, String locationURI, XsdSchemaCollection schemaCollection)
    {
        log.info("Entered in buildWsdlDefinition");
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName(portType);
        wsdl11Definition.setLocationUri(locationURI);
        wsdl11Definition.setTargetNamespace(namespace);
        wsdl11Definition.setSchemaCollection(schemaCollection);
        return wsdl11Definition;
    }

    /**
     * Parses the incoming request message into a Document.
     */
    public static Document extractRequestDocument(MessageContext messageContext, DocumentBuilder builder) throws IOException, SAXException {
        WebServiceMessage request = messageContext.getRequest();
        ByteArrayOutputStream requestBytes = new ByteArrayOutputStream();
        request.writeTo(requestBytes);
        return builder.parse(new ByteArrayInputStream(requestBytes.toByteArray()));
    }


    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @return false to prevent Spring WS from overriding with default fault
     */

    public static boolean handleSchemaValidationErrors(MessageContext messageContext, String errorPath, String filter) {
        log.info("Schema validation failed.Entered in handleSchemaValidationErrors method ");
        try (InputStream staticXml = SoapInterceptorUtils.class.getClassLoader().getResourceAsStream(errorPath)) {
            if (staticXml == null) {
                log.error("schemaValidationError.xml not found");
                return true;
            }
            DocumentBuilder builder = SoapInterceptorUtils.getSecureDocumentBuilder();
            Document errorDoc = builder.parse(staticXml);
            Document requestDoc = SoapInterceptorUtils.extractRequestDocument(messageContext, builder);
            if(filter.equals("accountValidation")){
                updateDynamicFields(errorDoc, requestDoc);}
            else{
                updateFields(errorDoc, requestDoc);
            }
            SoapInterceptorUtils.sendCustomSoapFault(errorDoc);
            return false;
        } catch (Exception e) {
            log.error("Error during schema validation interception", e);
            throw new SchemaValidationException("Schema validation failure", e);
        }
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private static void updateDynamicFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        log.info("Entered in updateDynamicFields for accountValidation");
        String txnId = SoapInterceptorUtils.getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        String systemId = SoapInterceptorUtils.getValueFromRequest(requestDoc, SYSTEM_ID);

        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
        handleRefRequestIds(errorDoc, requestDoc, txnId, systemId);
    }
    /**
     * Handles removal of <refRequestIds> node if <requestIds> is missing or empty.
     */
    private static void handleRefRequestIds(Document errorDoc, Document requestDoc, String txnId, String systemId) {
        log.info("Entered in handleRefRequestIds");
        Node requestIds = getNode(requestDoc, "requestIds");
        Node refRequestIds = getNode(errorDoc, "refRequestIds");

        if (shouldRemoveEntireRefRequestIds(requestIds, refRequestIds)) return;

        if (refRequestIds != null) {
            removeMissingChildNodes(refRequestIds, txnId, systemId);
            removeIfEmpty(refRequestIds);
        }
    }

    private static boolean shouldRemoveEntireRefRequestIds(Node requestIds, Node refRequestIds) {
        if (isNodeEmpty(requestIds) && refRequestIds != null) {
            refRequestIds.getParentNode().removeChild(refRequestIds);
            return true;
        }
        return false;
    }

    private static void removeMissingChildNodes(Node refRequestIds, String txnId, String systemId) {
        if (txnId == null) removeNodes(refRequestIds, TAG_TRANSACTION_ID);
        if (systemId == null) removeNodes(refRequestIds, SYSTEM_ID);
    }

    private static void removeIfEmpty(Node node) {
        if (!node.hasChildNodes()) {
            node.getParentNode().removeChild(node);
        }
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private static void updateFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        log.info("Entered in updateFields for customer retrieval");
        String txnId = SoapInterceptorUtils.getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        SoapInterceptorUtils. replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
        handleRequestIds(errorDoc, requestDoc);
    }

    /**
     * Handles removal of {@code <refRequestIds>} node in the error response
     * if {@code <requestIds>} is missing or missing specific fields (systemId, transactionId).
     * @param errorDoc   the static error XML document
     * @param requestDoc the SOAP request XML document
     */
    public static void handleRequestIds(Document errorDoc, Document requestDoc) {
        log.debug("Entered in handleRequestIds");
        NodeList requestIdNodes = requestDoc.getElementsByTagNameNS("*", "requestIds");
        Node refRequestIds = getNode(errorDoc, "refRequestIds");
        ValidationFlags flags = extractValidationFlags(requestIdNodes);
        if (refRequestIds != null) {
            handleRefRequestIds(refRequestIds, flags);}
    }

    /**
     * Extracts flags from the request's {@code <requestIds>} elements.
     * Determines if a node with {@code systemId = "RequestID"} exists,
     * and whether it contains {@code <transactionId>} and {@code <systemId>} sub-elements.
     *
     * @param requestIdNodes list of {@code <requestIds>} elements in the request
     * @return a record with flags indicating presence of required fields
     */
    private static ValidationFlags extractValidationFlags(NodeList requestIdNodes) {

        for (int i = 0; i < requestIdNodes.getLength(); i++) {
            Node requestIdsNode = requestIdNodes.item(i);
            NodeList children = requestIdsNode.getChildNodes();
            ValidationFlags flags = analyzeRequestIdChildren(children);
            if (flags.foundRequestIDSystemId()) {
                return flags;
            }
        }
        return new ValidationFlags(false, false, false);
    }

    /**
     * Analyzes the children of a {@code <requestIds>} node to determine
     * whether it contains a valid "RequestID" systemId and presence of specific sub-elements.
     *
     * @param children NodeList of child elements inside a {@code <requestIds>} node
     * @return ValidationFlags record indicating which tags are present
     */
    private static ValidationFlags analyzeRequestIdChildren(NodeList children) {
        boolean txnIdPresent = false;
        boolean systemIdPresent = false;
        String systemId = null;

        for (int j = 0; j < children.getLength(); j++) {
            Node child = children.item(j);
            String tag = child.getLocalName();

            if (SYSTEM_ID.equals(tag)) {
                systemId = child.getTextContent();
                systemIdPresent = true;
            } else if (TAG_TRANSACTION_ID.equals(tag)) {
                txnIdPresent = true;
            }
        }

        boolean isRequestID = "RequestID".equals(systemId);
        return new ValidationFlags(isRequestID, txnIdPresent, systemIdPresent);
    }
    /**
     * Handles logic for modifying or removing {@code <refRequestIds>} in the error response
     * based on the extracted validation flags.
     *
     * @param refRequestIds the {@code <refRequestIds>} node in error XML
     * @param flags         extracted field presence indicators
     */
    private static void handleRefRequestIds(Node refRequestIds, ValidationFlags flags) {
        log.debug("Entered in handleRefRequestIds");
        if (!flags.foundRequestIDSystemId()) {
            removeChildNode(refRequestIds,null);
            return;}
        if (!flags.hasTxnId()) {
            removeChildNode(refRequestIds, TAG_TRANSACTION_ID);}
        if (!flags.hasSystemId()) {
            removeChildNode(refRequestIds, SYSTEM_ID);}
        if (!refRequestIds.hasChildNodes()) {
            removeChildNode(refRequestIds,null);
        }
    }



    /**
     * A container for boolean flags used to control the logic for request ID validation.
     * @param foundRequestIDSystemId whether a {@code <requestIds>} block with systemId=RequestID exists
     * @param hasTxnId               whether the matching block has a {@code <transactionId>}
     * @param hasSystemId            whether the matching block has a {@code <systemId>}
     */
    @SuppressWarnings("unused")
    private record ValidationFlags(boolean foundRequestIDSystemId, boolean hasTxnId, boolean hasSystemId) {
        // This method has no methods or logic because it is purily a data carrier
    }


}

package com.rbs.bdd.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Predicate;

import com.rbs.bdd.application.service.AccountValidationService;
import com.rbs.bdd.domain.enums.ServiceConstants;
import com.rbs.bdd.domain.enums.ValidationErrorType;
import com.rbs.bdd.domain.model.ErrorDetail;
import jakarta.xml.soap.SOAPException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.XMLConstants;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

/**
 * Utility class for validating account identifiers like IBAN or UBAN
 * across different service contexts such as Account Validation or Customer Retrieval.
 * <p>
 * This class centralizes error evaluation logic based on account type, identifier format,
 * length, and modulus check results.
 */
@Slf4j
public class ValidationUtils {
    /**
     * Immutable container representing a valid request configuration.
     * this record is left without methods or additional logic,as it is only
     *  used to group and transport request fields such as
     *  <ul>
     *     <li>{@code identifier} - contains account number </li>
     *     <li>{@code codeValue} - used to identify
     * whether account is UKBasicBankAccountNumber or InternationalBankAccountNumber</li>
     *      <li>{@code originalTxnId} - return the transactionId of the request </li>
     *       <li>{@code systemId} - returns the systemId from the request </li>
     *       </ul>
     */
    @SuppressWarnings("unused")
    public record RequestParams(String identifier, String codeValue, String originalTxnId, String systemId) {
        // this record is left without methods or additional logic,as it is only used to group and transport request fields

    }


    /**
     * Checks if the given node is empty or only contains non-element children.
     */
    public static boolean isNodeEmpty(Node node) {
        if (node == null) return true;
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) return false;
        }
        return true;
    }

    /**
     * Removes a specific child element from the parent node.
     */
    public static void removeNodes(Node parent, String tagName) {
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Validates the provided {@link RequestParams} based on predefined rules for
     * account type (UK Basic or International) and returns a mapped {@link ErrorDetail}
     * from the provided {@code errorMap} based on failure conditions.
     * <p>
     * This method is reusable across multiple services and logs the validation
     * outcome per service context.
     * @param p              the request parameter object containing account details
     * @param errorMap       a mapping of {@link ValidationErrorType} to corresponding {@link ErrorDetail}
     * @param ibanValidator  a predicate used to validate IBAN or UBAN using modulus or custom rule
     * @param serviceContext a string to log the calling service (e.g., "AccountValidation", "CustomerRetrieval")
     * @return an {@code Optional<ErrorDetail>} containing the matched error if validation fails; empty otherwise
     */
    public static Optional<ErrorDetail> validateAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            Predicate<String> ibanValidator,
            String serviceContext
    ) {
        if (ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT.equals(p.codeValue())) {
            log.info("Account Type is :"+ ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT);
            return validateUbanAccount(p, errorMap, ibanValidator, serviceContext);
        }

        if (ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT.equals(p.codeValue())) {
            log.info("Account Type is :"+ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT);
            return validateIbanAccount(p, errorMap, serviceContext);
        }

        return Optional.empty();
    }

    /**
     * Validates a UK Basic Bank Account (UBAN).
     */
    private static Optional<ErrorDetail> validateUbanAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            Predicate<String> ibanValidator,
            String context
    ) {
        log.error("Entered in validateUbanAccount ");
        if (!p.identifier().matches("\\d+")) {
            log.error("UBAN account is starting with GB prefix");
            return Optional.of(errorMap.get(ValidationErrorType.INVALID_PREFIX));
        }

        if (p.identifier().length() != 14) {
            log.error("UBAN account is not equal to 14 characters");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_LENGTH)
                    : errorMap.get(ValidationErrorType.INVALID_UBAN_LENGTH));
        }

        if (!ibanValidator.test(p.identifier())) {
            log.error("UBAN account is not valid");
            return Optional.of(errorMap.get(ValidationErrorType.INVALID_MODULUS));
        }

        log.info("No error for UBAN [{}] in {} with identifier: {}", p.codeValue(), context, p.identifier());
        return Optional.empty();
    }

    /**
     * Validates an International Bank Account Number (IBAN).
     */
    private static Optional<ErrorDetail> validateIbanAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            String context
    ) {

        if (!p.identifier().startsWith("GB")) {
            log.error("IBAN account is not starting with GB prefix");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_PREFIX)
                    : errorMap.get(ValidationErrorType.INVALID_COUNTRY_CODE));
        }

        if (p.identifier().length() != 22) {
            log.error("IBAN account is not equal to 22 characters");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_LENGTH)
                    : errorMap.get(ValidationErrorType.INVALID_IBAN_LENGTH));

        }

        log.info("No error for IBAN [{}] in {} with identifier: {}", p.codeValue(), context, p.identifier());
        return Optional.empty();
    }




    /**
     * Generates a unique transaction ID using UUID.
     */
    public static String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }
    /**
     * Removes a child node from the specified parent node.
     * <ul>
     *     <li>If {@code tagName} is {@code null}, it removes the node directly from its parent.</li>
     *     <li>If {@code tagName} is provided, it searches the children of the parent node and removes the first match based on local name.</li>
     * </ul>
     *
     * @param parentOrNode the node to be removed directly (if {@code tagName} is null), or parent node (if tagName is provided)
     * @param tagName       the local name of the child node to remove; {@code null} for direct removal
     */
    public static void removeChildNode(Node parentOrNode, String tagName) {
        if (tagName == null) {
            removeDirectNode(parentOrNode);
        } else {
            removeChildByTag(parentOrNode, tagName);
        }
    }

    /**
     * Sets a value for the node matching the given XPath expression.
     */
    public static void setXPathValue(Document doc, String path, String value) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent(value);
        }
    }

    /**
     * Removes the given node from its parent if both are non-null.
     */
    private static void removeDirectNode(Node node) {
        if (node != null && node.getParentNode() != null) {
            node.getParentNode().removeChild(node);
        }
    }

    /**
     * Removes the first child of the parent that matches the given local tag name.
     */
    private static void removeChildByTag(Node parent, String tagName) {
        if (parent == null || tagName == null) return;

        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Finds a node by its local name using wildcard namespace.
     */
    public static Node getNode(Document doc, String localName) {
        NodeList nodes = doc.getElementsByTagNameNS("*", localName);
        return nodes.getLength() > 0 ? nodes.item(0) : null;
    }

    public static  void writeResponseToSoapMessage(WebServiceMessage message, Document responseDoc) throws TransformerException, SOAPException {
        log.info("Entered in writeResponseToSoapMessage");
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(responseDoc), new StreamResult(out));
        ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));
    }



}

package com.rbs.bdd;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;


/**

 * Main Spring boot entry class for the Esp Simulator application.
 * This class bootstraps the spring context and launches the application.

 * Main Spring boot entry class for the Esp Simulator application.
 * This class bootstraps the spring context and launches the application.
 */
@ComponentScan("com.rbs.bdd")
@SpringBootApplication(scanBasePackages = "com.rbs.bdd" )
       // ,exclude = {org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration.class})
public class EspSimulatorEngine {

    public static void main(String[] args) {
        SpringApplication.run(EspSimulatorEngine.class, args);
    }
}



