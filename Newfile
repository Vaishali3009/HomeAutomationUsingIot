package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.AccountValidationException;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.soap.MessageFactory;
import jakarta.xml.soap.SOAPBody;
import jakarta.xml.soap.SOAPMessage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit test suite for {@link AccountValidationService} which validates both successful
 * and error response scenarios based on incoming SOAP request data.
 *
 * This test uses a static SOAP XML template loaded and modified at runtime,
 * and verifies the final response structure using DOM + XPath assertions.
 */
class AccountValidationServiceTest {

    private AccountValidationService accountValidationService;

    /**
     * Initializes the test with a fresh instance of {@link AccountValidationService}.
     */
    @BeforeEach
    void setup() {
        accountValidationService = new AccountValidationService();
    }

    /**
     * Loads the SOAP request XML from a template file, replaces placeholder variables,
     * and unmarshals only the payload into a {@link ValidateArrangementForPaymentRequest} object.
     *
     * @param identifier the IBAN or UBAN
     * @param codeValue the account code value type
     * @return deserialized Java request object
     * @throws Exception in case of JAXB or file issues
     */
    private ValidateArrangementForPaymentRequest loadRequest(String identifier, String codeValue) throws Exception {
        String template = Files.readString(Path.of("src/test/resources/static-request/static-request.xml"));
        String finalXml = template
                .replace("${IDENTIFIER}", identifier)
                .replace("${CODEVALUE}", codeValue);

        SOAPMessage soapMessage = MessageFactory.newInstance()
                .createMessage(null, new ByteArrayInputStream(finalXml.getBytes(StandardCharsets.UTF_8)));
        SOAPBody body = soapMessage.getSOAPBody();

        JAXBContext jaxbContext = JAXBContext.newInstance(ValidateArrangementForPaymentRequest.class);
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        JAXBElement<ValidateArrangementForPaymentRequest> jaxbElement =
                unmarshaller.unmarshal(body.getElementsByTagNameNS("*", "validateArrangementForPayment").item(0),
                        ValidateArrangementForPaymentRequest.class);

        return jaxbElement.getValue();
    }

    /**
     * Invokes the SOAP validation service with the given request and returns the
     * transformed SOAP response as a DOM document.
     *
     * @param request validated SOAP request
     * @return DOM document of modified response
     * @throws Exception in case of failure
     */
    private Document invokeServiceAndGetModifiedDoc(ValidateArrangementForPaymentRequest request) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        WebServiceMessage message = new SaajSoapMessage(MessageFactory.newInstance().createMessage());
        accountValidationService.validateSchema(request);
        accountValidationService.validateBusinessRules(request, message);
        message.writeTo(outputStream);

        return DocumentBuilderFactory.newInstance().newDocumentBuilder()
                .parse(new ByteArrayInputStream(outputStream.toByteArray()));
    }

    /**
     * Evaluates and returns the XPath value from the given DOM document.
     *
     * @param doc the DOM document
     * @param expression the XPath expression
     * @return extracted value
     * @throws Exception if XPath fails
     */
    private String getXpathValue(Document doc, String expression) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        return xpath.evaluate(expression, doc);
    }

    /**
     * Validates success response for IBAN_1 with expected values:
     * Restricted status, Switched, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_1 - Domestic Restricted, Switched, Modulus Passed")
    void testIBAN1_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("60161331926801", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);

        System.out.println("=== Full SOAP Response ===");
        javax.xml.transform.TransformerFactory.newInstance()
                .newTransformer()
                .transform(new javax.xml.transform.dom.DOMSource(doc),
                        new javax.xml.transform.stream.StreamResult(System.out));
        System.out.println("===========================");



        assertEquals("Domestic - Restricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Switched", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));

    }

    /**
     * Validates success response for IBAN_2 with expected values:
     * Restricted status, Not Switching, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_2 - Domestic Restricted, Not Switching, Modulus Passed")
    void testIBAN2_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("12345698765437", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        System.out.println("=== Full SOAP Response ===");
        javax.xml.transform.TransformerFactory.newInstance()
                .newTransformer()
                .transform(new javax.xml.transform.dom.DOMSource(doc),
                        new javax.xml.transform.stream.StreamResult(System.out));
        System.out.println("===========================");
        assertEquals("Domestic - Restricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Not Switching", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates success response for IBAN_3 with expected values:
     * Unrestricted status, Switched, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_3 - Domestic Unrestricted, Switched, Modulus Passed")
    void testIBAN3_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("10201530093422", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Domestic - Unrestricted",getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Switched", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates success response for IBAN_4 with expected values:
     * Unrestricted status, Not Switching, Modulus Failed.
     */
    @Test
    @DisplayName("Success Response for IBAN_4 - Domestic Unrestricted, Not Switching, Modulus Failed")
    void testIBAN4_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("20201555555567", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Domestic - Unrestricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Not Switching", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Failed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates error response for unmatched IBAN.
     */
    @Test
    @DisplayName("Should return error when IBAN does not match any account")
    void testNoMatch_MOD97Failure() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB94BARC10201530093420", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("MOD97 failure for the IBAN", getXpathValue(doc, "//*[local-name()='description']"));
        assertEquals("Failed", getXpathValue(doc, "//*[local-name()='cmdStatus']"));
    }

    /**
     * Validates error response for IBAN with invalid length.
     */
    @Test
    @DisplayName("Should return error for invalid IBAN length")
    void testInvalidIbanLength() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB123", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Length of IBAN is Invalid", getXpathValue(doc, "//*[local-name()='description']"));
    }

    /**
     * Validates error response for UBAN with invalid length.
     */
    @Test
    @DisplayName("Should return error for invalid UBAN length")
    void testInvalidUbanLength() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("123456", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("UBAN should be 14 digits", getXpathValue(doc, "//*[local-name()='description']"));
    }

    /**
     * Validates DB2 SQL error response when GB-prefixed UBAN is used.
     */
    @Test
    @DisplayName("Should return DB2 SQL error for GB UBAN")
    void testDb2ErrorForGBUban() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB12345678901234", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertTrue(getXpathValue(doc, "//*[local-name()='description']").contains("Service GRPUB"));
    }

    /**
     * Validates country code error when IBAN does not start with GB.
     */
    @Test
    @DisplayName("Should return country code error when IBAN does not start with GB")
    void testWrongCountryCode() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("FR1234567890123456789012", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Country code is not found in Db, try  with the correct country code", getXpathValue(doc, "//*[local-name()='description']"));
    }
}
