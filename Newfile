package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.AccountValidationException;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.soap.MessageFactory;
import jakarta.xml.soap.SOAPBody;
import jakarta.xml.soap.SOAPMessage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit test suite for {@link AccountValidationService} which validates both successful
 * and error response scenarios based on incoming SOAP request data.
 *
 * This test uses a static SOAP XML template loaded and modified at runtime,
 * and verifies the final response structure using DOM + XPath assertions.
 */
class AccountValidationServiceTest {

    private AccountValidationService accountValidationService;

    /**
     * Initializes the test with a fresh instance of {@link AccountValidationService}.
     */
    @BeforeEach
    void setup() {
        accountValidationService = new AccountValidationService();
    }

    /**
     * Loads the SOAP request XML from a template file, replaces placeholder variables,
     * and unmarshals only the payload into a {@link ValidateArrangementForPaymentRequest} object.
     *
     * @param identifier the IBAN or UBAN
     * @param codeValue the account code value type
     * @return deserialized Java request object
     * @throws Exception in case of JAXB or file issues
     */
    private ValidateArrangementForPaymentRequest loadRequest(String identifier, String codeValue) throws Exception {
        String template = Files.readString(Path.of("src/test/resources/static-request/static-request.xml"));
        String finalXml = template
                .replace("${IDENTIFIER}", identifier)
                .replace("${CODEVALUE}", codeValue);

        SOAPMessage soapMessage = MessageFactory.newInstance()
                .createMessage(null, new ByteArrayInputStream(finalXml.getBytes(StandardCharsets.UTF_8)));
        SOAPBody body = soapMessage.getSOAPBody();

        JAXBContext jaxbContext = JAXBContext.newInstance(ValidateArrangementForPaymentRequest.class);
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        JAXBElement<ValidateArrangementForPaymentRequest> jaxbElement =
                unmarshaller.unmarshal(body.getElementsByTagNameNS("*", "validateArrangementForPayment").item(0),
                        ValidateArrangementForPaymentRequest.class);

        return jaxbElement.getValue();
    }

    /**
     * Invokes the SOAP validation service with the given request and returns the
     * transformed SOAP response as a DOM document.
     *
     * @param request validated SOAP request
     * @return DOM document of modified response
     * @throws Exception in case of failure
     */
    private Document invokeServiceAndGetModifiedDoc(ValidateArrangementForPaymentRequest request) throws Exception {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        WebServiceMessage message = new SaajSoapMessage(MessageFactory.newInstance().createMessage());
        accountValidationService.validateSchema(request);
        accountValidationService.validateBusinessRules(request, message);
        message.writeTo(outputStream);

        return DocumentBuilderFactory.newInstance().newDocumentBuilder()
                .parse(new ByteArrayInputStream(outputStream.toByteArray()));
    }

    /**
     * Evaluates and returns the XPath value from the given DOM document.
     *
     * @param doc the DOM document
     * @param expression the XPath expression
     * @return extracted value
     * @throws Exception if XPath fails
     */
    private String getXpathValue(Document doc, String expression) throws Exception {
        XPath xpath = XPathFactory.newInstance().newXPath();
        return xpath.evaluate(expression, doc);
    }

    /**
     * Validates success response for IBAN_1 with expected values:
     * Restricted status, Switched, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_1 - Domestic Restricted, Switched, Modulus Passed")
    void testIBAN1_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("60161331926801", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);

        System.out.println("=== Full SOAP Response ===");
        javax.xml.transform.TransformerFactory.newInstance()
                .newTransformer()
                .transform(new javax.xml.transform.dom.DOMSource(doc),
                        new javax.xml.transform.stream.StreamResult(System.out));
        System.out.println("===========================");



        assertEquals("Domestic - Restricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Switched", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));

    }

    /**
     * Validates success response for IBAN_2 with expected values:
     * Restricted status, Not Switching, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_2 - Domestic Restricted, Not Switching, Modulus Passed")
    void testIBAN2_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("12345698765437", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        System.out.println("=== Full SOAP Response ===");
        javax.xml.transform.TransformerFactory.newInstance()
                .newTransformer()
                .transform(new javax.xml.transform.dom.DOMSource(doc),
                        new javax.xml.transform.stream.StreamResult(System.out));
        System.out.println("===========================");
        assertEquals("Domestic - Restricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Not Switching", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates success response for IBAN_3 with expected values:
     * Unrestricted status, Switched, Modulus Passed.
     */
    @Test
    @DisplayName("Success Response for IBAN_3 - Domestic Unrestricted, Switched, Modulus Passed")
    void testIBAN3_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("10201530093422", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Domestic - Unrestricted",getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Switched", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Passed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates success response for IBAN_4 with expected values:
     * Unrestricted status, Not Switching, Modulus Failed.
     */
    @Test
    @DisplayName("Success Response for IBAN_4 - Domestic Unrestricted, Not Switching, Modulus Failed")
    void testIBAN4_SuccessResponse() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("20201555555567", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Domestic - Unrestricted", getXpathValue(doc, "//*[local-name()='accountingUnits']/*[local-name()='status']"));
        assertEquals("Not Switching", getXpathValue(doc, "//*[local-name()='switchingStatus']"));
        assertEquals("Failed", getXpathValue(doc, "//*[local-name()='modulusCheckStatus']/*[local-name()='codeValue']"));
    }

    /**
     * Validates error response for unmatched IBAN.
     */
    @Test
    @DisplayName("Should return error when IBAN does not match any account")
    void testNoMatch_MOD97Failure() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB94BARC10201530093420", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("MOD97 failure for the IBAN", getXpathValue(doc, "//*[local-name()='description']"));
        assertEquals("Failed", getXpathValue(doc, "//*[local-name()='cmdStatus']"));
    }

    /**
     * Validates error response for IBAN with invalid length.
     */
    @Test
    @DisplayName("Should return error for invalid IBAN length")
    void testInvalidIbanLength() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB123", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Length of IBAN is Invalid", getXpathValue(doc, "//*[local-name()='description']"));
    }

    /**
     * Validates error response for UBAN with invalid length.
     */
    @Test
    @DisplayName("Should return error for invalid UBAN length")
    void testInvalidUbanLength() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("123456", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("UBAN should be 14 digits", getXpathValue(doc, "//*[local-name()='description']"));
    }

    /**
     * Validates DB2 SQL error response when GB-prefixed UBAN is used.
     */
    @Test
    @DisplayName("Should return DB2 SQL error for GB UBAN")
    void testDb2ErrorForGBUban() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("GB12345678901234", "UKBasicBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertTrue(getXpathValue(doc, "//*[local-name()='description']").contains("Service GRPUB"));
    }

    /**
     * Validates country code error when IBAN does not start with GB.
     */
    @Test
    @DisplayName("Should return country code error when IBAN does not start with GB")
    void testWrongCountryCode() throws Exception {
        ValidateArrangementForPaymentRequest req = loadRequest("FR1234567890123456789012", "InternationalBankAccountNumber");
        Document doc = invokeServiceAndGetModifiedDoc(req);
        assertEquals("Country code is not found in Db, try  with the correct country code", getXpathValue(doc, "//*[local-name()='description']"));
    }
}

-----------------------

package com.rbs.bdd.application.service;


import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.port.out.AccountValidationPort;
import com.rbs.bdd.domain.enums.*;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;


import static com.rbs.bdd.domain.enums.AccountStatus.DOMESTIC_RESTRICTED;
import static com.rbs.bdd.domain.enums.AccountStatus.DOMESTIC_UNRESTRICTED;
import static com.rbs.bdd.domain.enums.ModulusCheckStatus.FAILED;
import static com.rbs.bdd.domain.enums.ModulusCheckStatus.PASSED;
import static com.rbs.bdd.domain.enums.ServiceConstants.IBANs.*;
import static com.rbs.bdd.domain.enums.SwitchingStatus.NOT_SWITCHING;
import static com.rbs.bdd.domain.enums.SwitchingStatus.SWITCHED;

/**
 * Service responsible for validating SOAP requests for account validation and returning
 * static success or error responses based on configured rules.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AccountValidationService implements AccountValidationPort {


    /**
     * Logs the fact that schema validation is already handled by Spring WS.
     */
    @Override
    public void validateSchema(ValidateArrangementForPaymentRequest request) {
        log.info("Schema validation completed by Spring WS");
    }

    /**
     * Applies business rule validation based on account identifiers, code values, and IBAN/UBAN checks.
     * Depending on the logic, either a static success or error response is returned.
     *
     * @param request the incoming SOAP request
     * @param message the SOAP response message to be modified
     */
    @Override
    public void validateBusinessRules(ValidateArrangementForPaymentRequest request, WebServiceMessage message) {
        try {
            log.info("Starting business rule validation for request.");
            RequestParams params = extractParams(request);
            XPath xpath = XPathFactory.newInstance().newXPath();
            Document responseDoc;

            Optional<ErrorDetail> error = determineError(params);
            if (error.isPresent()) {
                log.info("Business error condition detected: {}", error.get().description());
                responseDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH);
                applyErrorResponse(responseDoc, xpath, error.get(), params.originalTxnId);
            } else {
                Optional<ResponseConfig> config = determineMatchingConfig(params);
                if (config.isPresent()) {
                    log.info("Matched account configuration: {}", config.get());
                    responseDoc = loadAndParseXml("static-response/account-validation/success-response.xml");
                    updateSuccessResponse(responseDoc, xpath, config.get(), params);
                } else {
                    log.warn("No account matched. Returning MOD97 failure.");
                    responseDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH);
                    applyErrorResponse(responseDoc, xpath, ErrorConstants.ERR_MOD97_IBAN.detail(), params.originalTxnId);
                }
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream();
           TransformerFactory transformerFactory = TransformerFactory.newInstance();
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,"");
            transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,"");
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(new DOMSource(responseDoc), new StreamResult(out));
            ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                    .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));

            log.info("Business response prepared and set successfully.");
        } catch (Exception ex) {
            log.error("Business rule validation failed", ex);
            throw new AccountValidationException("Validation failed", ex);
        }
    }

    /**
     * Extracts key fields like identifier, codeValue, transactionId, and systemId from the SOAP request.
     */
    private RequestParams extractParams(ValidateArrangementForPaymentRequest request) {
        String identifier = request.getArrangementIdentifier().getIdentifier();
        String codeValue = request.getArrangementIdentifier().getContext().getCodeValue();
        String txnId = request.getRequestHeader().getRequestIds().getFirst().getTransactionId();
        String systemId = request.getRequestHeader().getRequestIds().getFirst().getSystemId();
        log.debug("Extracted request parameters: identifier={}, codeValue={}, txnId={}, systemId={}",
                identifier, codeValue, txnId, systemId);
        return new RequestParams(identifier, codeValue, identifier.length(), txnId, systemId);
    }

    /**
     * Validates error conditions such as invalid IBAN/UBAN format or mismatched values.
     */
    private Optional<ErrorDetail> determineError(RequestParams p) {
        Optional<ErrorDetail> errorDetail = Optional.empty();

    if (ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT.equals(p.codeValue())) {
        if (!p.identifier().startsWith("GB")) {
            errorDetail = Optional.of(ErrorConstants.ERR_WRONG_COUNTRY_CODE.detail());
        } else if (p.length() != 22) {
            errorDetail = Optional.of(ErrorConstants.ERR_INVALID_IBAN_LENGTH.detail());
        }
        else{
            log.info("No Error was found for IBAN account number :{} with identifier :{}", p.codeValue,p.identifier);
        }
    } else if (ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT.equals(p.codeValue())) {
        if (p.identifier().startsWith("GB")) {
            errorDetail = Optional.of(ErrorConstants.ERR_DB2_SQL.detail());
        } else if (p.length() != 14) {
            errorDetail = Optional.of(ErrorConstants.ERR_INVALID_UBAN_LENGTH.detail());
        } else if (!isUbanValid(p.identifier())) {
            errorDetail = Optional.of(ErrorConstants.ERR_MOD97_UBAN.detail());
        }
        else{
            log.info("No Error was found for UBAN account number :{} with identifier :{}", p.codeValue,p.identifier);
        }
    }

    return errorDetail;
    }

    /**
     * Matches the request against known account types and configurations.
     */
    private Optional<ResponseConfig> determineMatchingConfig(RequestParams p) {

        Map<String, ResponseConfig> ruleMap = Map.of(
        IBAN_1, new ResponseConfig(DOMESTIC_RESTRICTED, SWITCHED, PASSED),
        IBAN_2, new ResponseConfig(DOMESTIC_RESTRICTED, NOT_SWITCHING, PASSED),
        IBAN_3, new ResponseConfig(DOMESTIC_UNRESTRICTED, SWITCHED, PASSED),
        IBAN_4, new ResponseConfig(DOMESTIC_UNRESTRICTED, NOT_SWITCHING, FAILED)
    );

    return ruleMap.entrySet().stream()
        .filter(e -> isMatch(p, e.getKey()))
        .findFirst()
        .map(Map.Entry::getValue)
        .map(Optional::of)
        .orElse(Optional.empty());

    }

    /**
     * Checks if the request identifier matches exactly or by suffix.
     */
    private boolean isMatch(RequestParams p, String account) {
        return p.identifier.equals(account) || extractLast14Digits(account).equals(p.identifier);
    }

    /**
     * Verifies if the given UBAN matches the suffix of known IBANs.
     */
    private boolean isUbanValid(String identifier) {
        return ServiceConstants.IBANs.ALL_IBANS.stream()
                .map(this::extractLast14Digits)
                .anyMatch(ibanSuffix -> ibanSuffix.equals(identifier));
    }

    /**
     * Extracts last 14 digits from a given IBAN string.
     */
    private String extractLast14Digits(String iban) {
        return iban.length() >= 14 ? iban.substring(iban.length() - 14) : "";
    }

    /**
     * Reads and parses a static XML file from the classpath.
     */
    private Document loadAndParseXml(String path) throws ParserConfigurationException, IOException, SAXException {
        log.debug("Loading XML from path: {}", path);
        InputStream xml = getClass().getClassLoader().getResourceAsStream(path);
        if (Objects.isNull(xml)) {
            log.error("XML file not found at path: {}", path);
            throw new AccountValidationException("XML not found: " + path);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(xml);
    }

    /**
     * Populates values in the success response based on matched config.
     */
    private void updateSuccessResponse(Document doc, XPath xpath, ResponseConfig config, RequestParams p) throws XPathExpressionException {
        updateText(xpath, doc, "//responseId/systemId", p.systemId);
        updateText(xpath, doc, "//responseId/transactionId", generateTxnId());
        updateText(xpath, doc, "//status", config.accountStatus.getValue());
        updateText(xpath, doc, "//switchingStatus", config.switchingStatus.getValue());
        updateText(xpath, doc, "//modulusCheckStatus/codeValue", config.modulusCheckStatus.getValue());
        log.info("Updated response XML with success values");
    }

    /**
     * Populates values in the static error response XML.
     */
    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail errorDetail, String txnId) throws XPathExpressionException {
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_REF_REQUEST_TXN_ID, txnId);
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_DESCRIPTION, errorDetail.description());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RETURN_CODE, errorDetail.returnCode());
        if (Objects.nonNull(errorDetail.systemNotificationDesc())) {
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_DESC, errorDetail.systemNotificationDesc());
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_CODE, errorDetail.returnCode());
        } else {
            Node node = (Node) xpath.evaluate(ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (node != null && node.getParentNode() != null) {
                node.getParentNode().removeChild(node);
                log.debug("Removed systemNotification block as it was not applicable.");
            }
        }
        log.info("Updated response XML with error values: {}", errorDetail.description());
    }

    /**
     * Utility method to update a specific XML node’s text content.
     */
    private void updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) {
            node.setTextContent(value);
            log.debug("Updated XML node {} with value {}", path, value);
        }
    }

    /**
     * Generates a unique transaction ID string.
     */
    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

    /**
     * Immutable container representing a valid request configuration.
     * this record is left without methods or additional logic,as it is only
     *  used to group and transport request fields such as
     *  <ul>
     *     <li>{@code identifier} - contains account number </li>
     *     <li>{@code codeValue} - used to identify
     * whether account is UKBasicBankAccountNumber or InternationalBankAccountNumber</li>
     *     <li>{@code length} - returns length of account number </li>
     *      <li>{@code originalTxnId} - return the transactionId of the request </li>
     *       <li>{@code systemId} - returns the systemId from the request </li>
     */
     @SuppressWarnings("unused")
    private record RequestParams(String identifier, String codeValue, int length, String originalTxnId,String systemId) {
    // this record is left without methods or additional logic,as it is only used to group and transport request fields
     }

    /**
     * Immutable container representing a valid account configuration.
     * this record is left without methods or additional logic,as it is only
     * used to group and transport validation results such as
     * <ul>
     *     <li>{@code accountStatus} - the classification of the account(eg , restricted,unrestricted)</li>
     *      <li>{@code switchingStatus} - whether the account has been switched or not switching </li>
     *       <li>{@code modulusStatus} - result of modulus check </li>
     * </ul>
     */
     @SuppressWarnings("unused")
    private record ResponseConfig(AccountStatus accountStatus, SwitchingStatus switchingStatus,ModulusCheckStatus modulusCheckStatus) {
     // this record is left without methods or additional logic,as it is only used to group and transport validation results
     }
}


------------------
package com.rbs.bdd.application.service;




import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.port.out.RetrieveCustomerPort;
import com.rbs.bdd.domain.enums.CustomerNameMapping;
import com.rbs.bdd.domain.enums.ErrorConstants;
import com.rbs.bdd.domain.enums.ServiceConstants;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import static com.rbs.bdd.domain.enums.ServiceConstants.XPath.*;

/**
 * Service to handle logic for retrieving customer details based on account number.
 * Matches specific identifiers and dynamically updates SOAP XML response.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class CustomerRetrievalService implements RetrieveCustomerPort {

    private static final Logger logger = LoggerFactory.getLogger(CustomerRetrievalService.class);
    private static final String STATIC_RESPONSE_PATH = "static-response/customer-retrieval/success-response.xml";

    @Override
    public void validateSchema(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("Schema validated successfully by Spring WS.");
    }

    @Override
    public void retrieveCustomer(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message) {
        try {
            RequestParams params = extractParams(request);
            XPath xpath = XPathFactory.newInstance().newXPath();
            Document responseDoc;

            Optional<ErrorDetail> error = determineError(params);
            if (error.isPresent()) {
                responseDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH_FOR_CUSTOMER_RETRIEVAL);
                applyErrorResponse(responseDoc, xpath, error.get(), params.originalTxnId());
            } else {
                CustomerNameMapping matched = CustomerNameMapping.fromIdentifier(params.identifier);
                if (matched != null) {
                    responseDoc = loadAndParseXml(STATIC_RESPONSE_PATH);
                    updateName(responseDoc, xpath, matched.getFirstName(), matched.getLastName(),matched.getPrefixType());
                    logger.info("Returning matched customer response for IBAN: {}", matched.getIban());
                } else {
                    responseDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH);
                    applyErrorResponse(responseDoc, xpath, ErrorConstants.ERR_MOD97_IBAN.detail(), params.originalTxnId);
                }
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.transform(new DOMSource(responseDoc), new StreamResult(out));

            ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                    .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));

        } catch (Exception e) {
            logger.error("Customer retrieval failed", e);
            throw new RuntimeException("Customer retrieval failed", e);
        }
    }

    private void updateName(Document doc, XPath xpath, String firstName, String lastName,String prefixType) throws XPathExpressionException {
        updateText(xpath, doc, XPATH_PREFIX_TYPE, prefixType);
        updateText(xpath, doc, XPATH_FIRST_NAME, firstName);
        updateText(xpath, doc, XPATH_LAST_NAME, lastName);
    }

    private Optional<ErrorDetail> determineError(RequestParams p) {

        Optional<ErrorDetail> errorDetail = Optional.empty();

        if (ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT.equals(p.codeValue())) {
            if (!p.identifier().startsWith("GB")) {
                errorDetail = Optional.of(ErrorConstants.ERR_WRONG_COUNTRY_CODE.detail());
            } else if (p.length() != 22) {
                errorDetail = Optional.of(ErrorConstants.ERR_INVALID_IBAN_LENGTH.detail());
            }
            else{
                log.info("No Error was found for IBAN account number :{} with identifier :{}", p.codeValue,p.identifier);
            }
        } else if (ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT.equals(p.codeValue())) {
            if (p.identifier().startsWith("GB")) {
                errorDetail = Optional.of(ErrorConstants.ERR_UBAN_GB.detail());
            } else if (p.length() != 14) {
                errorDetail = Optional.of(ErrorConstants.ERR_INVALID_UBAN_LENGTH.detail());
            } else if (!isUbanValid(p.identifier())) {
                errorDetail = Optional.of(ErrorConstants.ERR_MOD97_UBAN.detail());
            }
            else{
                log.info("No Error was found for UBAN account number :{} with identifier :{}", p.codeValue,p.identifier);
            }
        }

        return errorDetail;
    }

    /**
     * Verifies if the given UBAN matches the suffix of known IBANs.
     */
    private boolean isUbanValid(String identifier) {
        return ServiceConstants.IBANs.ALL_IBANS.stream()
                .map(this::extractLast14Digits)
                .anyMatch(ibanSuffix -> ibanSuffix.equals(identifier));
    }

    /**
     * Extracts last 14 digits from a given IBAN string.
     */
    private String extractLast14Digits(String iban) {
        return iban.length() >= 14 ? iban.substring(iban.length() - 14) : "";
    }
    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail detail, String txnId) throws XPathExpressionException {
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_REF_REQUEST_TXN_ID, txnId);
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_DESCRIPTION, detail.description());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RETURN_CODE, detail.returnCode());

        if (Objects.nonNull(detail.systemNotificationDesc())){
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_DESC, detail.systemNotificationDesc());
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_CODE, detail.returnCode());
        } else {
            Node node = (Node) xpath.evaluate(ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (Objects.nonNull(node)) node.getParentNode().removeChild(node);
        }
    }

    private void
    updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) node.setTextContent(value);
    }

    private Document loadAndParseXml(String path) throws Exception {
        InputStream stream = getClass().getClassLoader().getResourceAsStream(path);
        if (Objects.isNull(stream)) {
            log.error("XML file not found at path: {}", path);
            throw new AccountValidationException("XML not found: " + path);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(stream);
    }

    private RequestParams extractParams(RetrievePrimaryCustomerForArrRequest request) {
        return new RequestParams(
                request.getArrangementIdentifier().getIdentifier(),
                request.getArrangementIdentifier().getContext().getCodeValue(),
                request.getArrangementIdentifier().getIdentifier().length(),
                request.getRequestHeader().getRequestIds().getFirst().getTransactionId(),
                request.getRequestHeader().getRequestIds().getFirst().getSystemId()
        );
    }

    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

    private record RequestParams(String identifier, String codeValue, int length, String originalTxnId, String systemId) {}
}
