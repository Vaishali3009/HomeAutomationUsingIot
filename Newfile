package com.rbs.bdd.infrastructure.soap.interceptor;


import com.rbs.bdd.application.exception.SchemaValidationException;
import jakarta.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor; import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static com.rbs.bdd.common.ServiceConstants.SCHEMA_VALIDATION_ERROR_XML;
import static com.rbs.bdd.common.ServiceConstants.TAG_TRANSACTION_ID;


/**
 * Intercepts schema validation errors in SOAP requests and returns a custom SOAP fault response.
 * The response is based on a static XML file, with dynamic fields replaced using request data.
 */
public class AccountSchemaValidationInterceptor extends PayloadValidatingInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(AccountSchemaValidationInterceptor.class);

    private static final String PLACEHOLDER_TXN = "TXN_ID_PLACEHOLDER";
    private static final String PLACEHOLDER_RESPONSE = "RESPONSE_ID_PLACEHOLDER";

    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @param errors         the validation errors
     * @return false to prevent Spring WS from overriding with default fault
     */
    @Override
    public boolean handleRequestValidationErrors(MessageContext messageContext, SAXParseException[] errors) {
        logger.warn("Schema validation failed. Returning custom schemaValidationError.xml");

        try (InputStream staticXml = getClass().getClassLoader().getResourceAsStream(SCHEMA_VALIDATION_ERROR_XML)) {
            if (staticXml == null) {
                logger.error("schemaValidationError.xml not found");
                return true;
            }

            DocumentBuilder builder = getSecureDocumentBuilder();
            Document errorDoc = builder.parse(staticXml);
            Document requestDoc = extractRequestDocument(messageContext, builder);

            updateDynamicFields(errorDoc, requestDoc);

            sendCustomSoapFault(errorDoc);
            return false;
        } catch (Exception e) {
            logger.error("Error during schema validation interception", e);
            throw new SchemaValidationException("Schema validation failure", e);
        }
    }

    /**
     * Creates a secure, namespace-aware {@link DocumentBuilderFactory}.
     * <p>
     * This method disables external entity processing to prevent XML External Entity (XXE)
     * attacks and other injection vulnerabilities.
     *
     *
     * @return configured {@link DocumentBuilderFactory} instance
     * @throws ParserConfigurationException if security features cannot be set
     */
    private DocumentBuilder getSecureDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        return factory.newDocumentBuilder();
    }



    /**
     * Parses the incoming request message into a Document.
     */
    private Document extractRequestDocument(MessageContext messageContext, DocumentBuilder builder) throws IOException, SAXException {
        WebServiceMessage request = messageContext.getRequest();
        ByteArrayOutputStream requestBytes = new ByteArrayOutputStream();
        request.writeTo(requestBytes);
        return builder.parse(new ByteArrayInputStream(requestBytes.toByteArray()));
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private void updateDynamicFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        String txnId = getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        String systemId = getValueFromRequest(requestDoc, "systemId");

        replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));

        handleRefRequestIds(errorDoc, requestDoc, txnId, systemId);
    }

    /**
     * Handles removal of <refRequestIds> node if <requestIds> is missing or empty.
     */
    private void handleRefRequestIds(Document errorDoc, Document requestDoc, String txnId, String systemId) {
        Node requestIds = getNode(requestDoc, "requestIds");
        boolean isEmpty = isNodeEmpty(requestIds);

        Node refRequestIds = getNode(errorDoc, "refRequestIds");

        if (isEmpty  && refRequestIds != null) {
            refRequestIds.getParentNode().removeChild(refRequestIds);
            return;
        }

        if (refRequestIds != null) {
            if (txnId == null) removeNode(refRequestIds, "transactionId");
            if (systemId == null) removeNode(refRequestIds, "systemId");
            if (!refRequestIds.hasChildNodes()) {
                refRequestIds.getParentNode().removeChild(refRequestIds);
            }
        }
    }

    /**
     * Sends the final SOAP error response with HTTP 500.
     */
    private void sendCustomSoapFault(Document errorDoc) throws TransformerException, IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,"");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,"");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(errorDoc), new StreamResult(out));

        HttpServletResponse servletResponse =
                ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getResponse();

        if (servletResponse != null && !servletResponse.isCommitted()) {
            servletResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            servletResponse.setContentType("text/xml;charset=UTF-8");
            servletResponse.getOutputStream().write(out.toByteArray());
            servletResponse.flushBuffer();
        }
    }

    /**
     * Retrieves the text content of a given tag from the request document.
     */
    private String getValueFromRequest(Document doc, String tag) {
        NodeList list = doc.getElementsByTagNameNS("*", tag);
        return list.getLength() > 0 ? list.item(0).getTextContent() : null;
    }

    /**
     * Finds a node by its local name using wildcard namespace.
     */
    private Node getNode(Document doc, String localName) {
        NodeList nodes = doc.getElementsByTagNameNS("*", localName);
        return nodes.getLength() > 0 ? nodes.item(0) : null;
    }

    /**
     * Replaces a text node matching a placeholder with a new value.
     */
    private void replaceTextNode(Document doc, String placeholder, String newValue) {
        NodeList nodes = doc.getElementsByTagNameNS("*", "transactionId");
        for (int i = 0; i < nodes.getLength(); i++) {
            Node txn = nodes.item(i);
            if (placeholder.equals(txn.getTextContent())) {
                txn.setTextContent(newValue);
            }
        }
    }

    /**
     * Sets a value for the node matching the given XPath expression.
     */
    private void setXPathValue(Document doc, String path, String value) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent(value);
        }
    }

    /**
     * Removes a specific child element from the parent node.
     */
    private void removeNode(Node parent, String tagName) {
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Checks if the given node is empty or only contains non-element children.
     */
    private boolean isNodeEmpty(Node node) {
        if (node == null) return true;
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) return false;
        }
        return true;
    }

    /**
     * Generates a unique transaction ID using UUID.
     */
    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

    /**
     * Retrieves static XML file from classpath. Can be overridden in tests.
     *
     * @param path the classpath location of the file
     * @return input stream for the XML file
     */
    protected InputStream getClassLoaderResource(String path) {
        return getClass().getClassLoader().getResourceAsStream(path);
    }

}

-----------------------------

package com.rbs.bdd.infrastructure.soap.interceptor;


import com.rbs.bdd.application.exception.SchemaValidationException;
import jakarta.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static com.rbs.bdd.common.ServiceConstants.SCHEMA_VALIDATION_ERROR_XML;
import static com.rbs.bdd.common.ServiceConstants.TAG_TRANSACTION_ID;


/**
 * Intercepts schema validation errors in SOAP requests and returns a custom SOAP fault response.
 * The response is based on a static XML file, with dynamic fields replaced using request data.
 */
public class CustomerSchemaValidationInterceptor extends PayloadValidatingInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(CustomerSchemaValidationInterceptor.class);

    private static final String PLACEHOLDER_TXN = "TXN_ID_PLACEHOLDER";
    private static final String PLACEHOLDER_RESPONSE = "RESPONSE_ID_PLACEHOLDER";

    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @param errors         the validation errors
     * @return false to prevent Spring WS from overriding with default fault
     */
    @Override
    public boolean handleRequestValidationErrors(MessageContext messageContext, SAXParseException[] errors) {
        logger.warn("Schema validation failed. Returning custom schemaValidationError.xml");

        try (InputStream staticXml = getClass().getClassLoader().getResourceAsStream(SCHEMA_VALIDATION_ERROR_XML)) {
            if (staticXml == null) {
                logger.error("schemaValidationError.xml not found");
                return true;
            }

            DocumentBuilder builder = getSecureDocumentBuilder();
            Document errorDoc = builder.parse(staticXml);
            Document requestDoc = extractRequestDocument(messageContext, builder);

            updateDynamicFields(errorDoc, requestDoc);

            sendCustomSoapFault(errorDoc);
            return false;
        } catch (Exception e) {
            logger.error("Error during schema validation interception", e);
            throw new SchemaValidationException("Schema validation failure", e);
        }
    }

    /**
     * Creates a secure, namespace-aware {@link DocumentBuilderFactory}.
     * <p>
     * This method disables external entity processing to prevent XML External Entity (XXE)
     * attacks and other injection vulnerabilities.
     *
     *
     * @return configured {@link DocumentBuilderFactory} instance
     * @throws ParserConfigurationException if security features cannot be set
     */
    private DocumentBuilder getSecureDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        return factory.newDocumentBuilder();
    }



    /**
     * Parses the incoming request message into a Document.
     */
    private Document extractRequestDocument(MessageContext messageContext, DocumentBuilder builder) throws IOException, SAXException {
        WebServiceMessage request = messageContext.getRequest();
        ByteArrayOutputStream requestBytes = new ByteArrayOutputStream();
        request.writeTo(requestBytes);
        return builder.parse(new ByteArrayInputStream(requestBytes.toByteArray()));
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private void updateDynamicFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        String txnId = getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        String systemId = getValueFromRequest(requestDoc, "systemId");

        replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));

        handleRefRequestIds(errorDoc, requestDoc, txnId, systemId);
    }

    /**
     * Handles removal of <refRequestIds> node if <requestIds> is missing or empty.
     */
    private void handleRefRequestIds(Document errorDoc, Document requestDoc, String txnId, String systemId) {
        Node requestIds = getNode(requestDoc, "requestIds");
        boolean isEmpty = isNodeEmpty(requestIds);

        Node refRequestIds = getNode(errorDoc, "refRequestIds");

        if (isEmpty  && refRequestIds != null) {
            refRequestIds.getParentNode().removeChild(refRequestIds);
            return;
        }

        if (refRequestIds != null) {
            if (txnId == null) removeNode(refRequestIds, "transactionId");
            if (systemId == null) removeNode(refRequestIds, "systemId");
            if (!refRequestIds.hasChildNodes()) {
                refRequestIds.getParentNode().removeChild(refRequestIds);
            }
        }
    }

    /**
     * Sends the final SOAP error response with HTTP 500.
     */
    private void sendCustomSoapFault(Document errorDoc) throws TransformerException, IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,"");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,"");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(errorDoc), new StreamResult(out));

        HttpServletResponse servletResponse =
                ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getResponse();

        if (servletResponse != null && !servletResponse.isCommitted()) {
            servletResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            servletResponse.setContentType("text/xml;charset=UTF-8");
            servletResponse.getOutputStream().write(out.toByteArray());
            servletResponse.flushBuffer();
        }
    }

    /**
     * Retrieves the text content of a given tag from the request document.
     */
    private String getValueFromRequest(Document doc, String tag) {
        NodeList list = doc.getElementsByTagNameNS("*", tag);
        return list.getLength() > 0 ? list.item(0).getTextContent() : null;
    }

    /**
     * Finds a node by its local name using wildcard namespace.
     */
    private Node getNode(Document doc, String localName) {
        NodeList nodes = doc.getElementsByTagNameNS("*", localName);
        return nodes.getLength() > 0 ? nodes.item(0) : null;
    }

    /**
     * Replaces a text node matching a placeholder with a new value.
     */
    private void replaceTextNode(Document doc, String placeholder, String newValue) {
        NodeList nodes = doc.getElementsByTagNameNS("*", "transactionId");
        for (int i = 0; i < nodes.getLength(); i++) {
            Node txn = nodes.item(i);
            if (placeholder.equals(txn.getTextContent())) {
                txn.setTextContent(newValue);
            }
        }
    }

    /**
     * Sets a value for the node matching the given XPath expression.
     */
    private void setXPathValue(Document doc, String path, String value) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent(value);
        }
    }

    /**
     * Removes a specific child element from the parent node.
     */
    private void removeNode(Node parent, String tagName) {
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Checks if the given node is empty or only contains non-element children.
     */
    private boolean isNodeEmpty(Node node) {
        if (node == null) return true;
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) return false;
        }
        return true;
    }

    /**
     * Generates a unique transaction ID using UUID.
     */
    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

    /**
     * Retrieves static XML file from classpath. Can be overridden in tests.
     *
     * @param path the classpath location of the file
     * @return input stream for the XML file
     */
    protected InputStream getClassLoaderResource(String path) {
        return getClass().getClassLoader().getResourceAsStream(path);
    }

}

--------------------------

package com.rbs.bdd.infrastructure.config;

import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.application.exception.XsdSchemaLoadingException;
import com.rbs.bdd.infrastructure.soap.interceptor.AccountSchemaValidationInterceptor;
import com.rbs.bdd.infrastructure.soap.interceptor.CustomerSchemaValidationInterceptor;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.ws.config.annotation.EnableWs;
import org.springframework.ws.config.annotation.WsConfigurerAdapter;
import org.springframework.ws.server.EndpointInterceptor;
import org.springframework.ws.transport.http.MessageDispatcherServlet;
import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;
import org.springframework.xml.xsd.XsdSchemaCollection;
import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;
import org.springframework.core.io.FileSystemResource;
import java.util.stream.Stream;
import java.util.List;

import static com.rbs.bdd.common.ServiceConstants.NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL;

/**
 * Configures Spring Web Services (Spring WS) for the application.
 * <p>
 * This configuration includes:
 * <ul>
 *     <li>Publishing WSDL endpoints for SOAP web services</li>
 *     <li>Enabling automatic XML Schema (XSD) validation of incoming SOAP requests</li>
 *     <li>Registering interceptors for request validation</li>
 * </ul>
 */
@Configuration
@EnableWs
public class SoapWebServiceConfig extends WsConfigurerAdapter {

    /**
     * Registers the {@link MessageDispatcherServlet} which is the main dispatcher for Spring WS.
     * It handles SOAP messages and dispatches them to appropriate endpoints.
     *
     * @param context the Spring application context
     * @return servlet registration bean mapped to the /ws/* URI
     */
    @Bean
    public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(ApplicationContext context) {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        servlet.setApplicationContext(context);
        servlet.setTransformWsdlLocations(true);
        return new ServletRegistrationBean<>(servlet, "/ws/*");
    }

    /**
     * Adds a custom interceptor for schema validation. This interceptor validates incoming SOAP
     * messages against the configured XSD schema.
     *
     * @param interceptors list of interceptors to which this validation interceptor is added
     */
    @Override
    public void addInterceptors(List<EndpointInterceptor> interceptors) {


        CustomerSchemaValidationInterceptor customerRetrievalInterceptor = new CustomerSchemaValidationInterceptor();
        customerRetrievalInterceptor.setValidateRequest(true);   // Validate incoming SOAP requests
        customerRetrievalInterceptor.setValidateResponse(false); // Do not validate outgoing responses
        try {
            customerRetrievalInterceptor.setXsdSchemaCollection(updateCustomerRetrievalXsd());
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Request XML Schema Validation failed", e);
        }
        interceptors.add(customerRetrievalInterceptor);

        AccountSchemaValidationInterceptor validatingInterceptor = new AccountSchemaValidationInterceptor();
        validatingInterceptor.setValidateRequest(true);   // Validate incoming SOAP requests
        validatingInterceptor.setValidateResponse(false); // Do not validate outgoing responses
        customerRetrievalInterceptor.setIncludeNamespaces(List.of());
        try {
            validatingInterceptor.setXsdSchemaCollection(updateContactXsd());
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Request XML Schema Validation failed", e);
        }
        interceptors.add(validatingInterceptor);


    }

    /**
     * Publishes a WSDL endpoint based on the `ArrValidationForPaymentParameters.xsd` file.
     * This exposes the WSDL dynamically under /ws/ArrValidationForPaymentParameters.wsdl
     *
     * @return a configured WSDL definition bean
     * @throws SchemaValidationException if XSD loading fails
     */
    @Bean(name = "ArrValidationForPaymentParameters")
    public DefaultWsdl11Definition accountValidationWSDL() throws SchemaValidationException {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName("IArrValidationForPayment");
        wsdl11Definition.setLocationUri("/ws");
        wsdl11Definition.setTargetNamespace("http://com/rbsg/soa/C040PaymentManagement/ArrValidationForPayment/V01/");
        wsdl11Definition.setSchemaCollection(updateContactXsd());
        return wsdl11Definition;
    }

    /**
     * Loads the primary XSD schema (`ArrValidationForPaymentParameters.xsd`) from the classpath
     * and enables inlining for WSDL generation and schema validation.
     *
     * @return an XsdSchemaCollection used for both WSDL publishing and request validation
     * @throws XsdSchemaLoadingException if schema loading fails due to I/O or classpath errors
     */
    @Bean
    public XsdSchemaCollection updateContactXsd() {
        try {
            CommonsXsdSchemaCollection xsd = new CommonsXsdSchemaCollection(
                    new ClassPathResource("xsd/account-validation/ArrValidationForPaymentParameters.xsd"));
            xsd.setInline(true);
            return xsd;
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Failed to load XSD schema for SOAP validation", e);
        }
    }


    /**
     * Publishes a WSDL endpoint based on the `CustomerRetrievalForPaymentParameters.xsd` file.
     * This exposes the WSDL dynamically under /ws/CustomerRetrievalForPaymentParameters.wsdl
     *
     * @return a configured WSDL definition bean
     * @throws SchemaValidationException if XSD loading fails
     */
    @Bean(name = "CustomerRetrievalForPayment")
    public DefaultWsdl11Definition customerRetrievalWSDL() throws SchemaValidationException {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName("ICustomerRetrievalForPayment");
        wsdl11Definition.setLocationUri("/ws");
        wsdl11Definition.setTargetNamespace("http://com/rbsg/soa/C040PaymentManagement/CustomerRetrievalForPayment/V01/");
        wsdl11Definition.setSchemaCollection(updateCustomerRetrievalXsd());
        System.out.println("Here");
        return wsdl11Definition;
    }


    /**
     * Loads the primary XSD schema (`CustomerRetrievalForPaymentParameters.xsd`) from the classpath
     * and enables inlining for WSDL generation and schema validation.
     *
     * @return an XsdSchemaCollection used for both WSDL publishing and request validation
     * @throws XsdSchemaLoadingException if schema loading fails due to I/O or classpath errors
     */
    @Bean
    public XsdSchemaCollection updateCustomerRetrievalXsd() {

        try {
            System.out.println("Inside the try ");
            CommonsXsdSchemaCollection xsd = new CommonsXsdSchemaCollection(
                    new ClassPathResource("xsd/customer-retrieval/CustomerRetrievalForPaymentParameters.xsd"));
            xsd.setInline(true);

            return xsd;
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Failed to load XSD schema for SOAP validation", e);
        }
    }
}
