package com.rbs.bdd.application.awsconfig;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient;
import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest;
import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueResponse;

@Slf4j
@Configuration
public class AwsSecretManagerConfig {

    @Bean
    @ConditionalOnProperty(name = "secret.manager.enabled", havingValue = "true")
    public SecretsManagerClient secretsManagerClient(@Value("${aws.region}") String region,
                                                     @Value("${secret.datasource.name}") String secretDatasourceName) {
        log.info("AWS-AWS_REGION {}", region);
        SecretsManagerClient client = SecretsManagerClient.builder()
                .region(Region.of(region))
                .credentialsProvider(DefaultCredentialsProvider.create())
                .build();
        log.info("Verify access");
        GetSecretValueRequest request = GetSecretValueRequest.builder()
                .secretId(secretDatasourceName)
                .build();

        try {
            GetSecretValueResponse response = client.getSecretValue(request);
            if (response.sdkHttpResponse().isSuccessful()) {
                log.info("aws secret retrieved [{}] successfully [{}]", secretDatasourceName,
                        response.secretString());
            }
        } catch (Exception u) {
            log.error("Unable to get the secret", u);
        }
        return client;
    }
}

-----------------------
package com.rbs.bdd.application.awsconfig;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.rbs.bdd.application.exception.SecretsNotFoundException;
import com.zaxxer.hikari.HikariDataSource;
import liquibase.integration.spring.SpringLiquibase;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient;
import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest;
import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueResponse;
import software.amazon.awssdk.services.secretsmanager.model.SecretsManagerException;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Configuration
@ConditionalOnProperty(name = "secret.manager.enabled", havingValue = "true")

public class DatabaseConfig {
    private final ObjectMapper mapper = new ObjectMapper();

    @Value("${spring.datasource.base.url}")
    private String springDatasourceBaseUrl;

    @Value("${spring.datasource.username}")
    private String springDatasourceUsername;

    @Value("${spring.datasource.password}")
    private String springDatasourcePassword;

    @Value("${spring.liquibase.default-schema}")
    private String springLiquibaseDefaultSchema;

    @Value("${secret.datasource.name}")
    private String secretDatasourceName;

    @Autowired(required = false)
    private SecretsManagerClient secretsManagerClient;


    private static final String USERNAME = "username";
    private static final String PASSWORD = "password";
    private static final String DBNAME = "dbname";

    //Fetch kubernetes secrets from the aws server
    private Map<String, String> fetchSecrets(final SecretsManagerClient secretsManagerClient,
                                             final String secretName){

        log.debug("Request received to retrieve secrets for  : {}",secretName);
        Map<String, String> secretMap = new HashMap<>();
        GetSecretValueRequest request = GetSecretValueRequest.builder()
                .secretId(secretName)
                .build();

        GetSecretValueResponse response = secretsManagerClient.getSecretValue(request);
        if(response.sdkHttpResponse().isSuccessful()){
            log.info("Secret retrieved for [{}] ",secretName);
            try{
                secretMap = mapper.readValue(response.secretString(), Map.class);
                log.info("SecretMap: Username: {}", secretMap.get(USERNAME));
            } catch (Exception e) {
                log.error("unable to retrieve data from secret");
                throw new SecretsNotFoundException("Unable to retrieve data from secrets!");
            }
        }
        return secretMap;
    }

    @ConfigurationProperties(prefix = "spring.datasource")
    @ConditionalOnProperty(prefix = "spring.liquibase", name = "enabled", havingValue = "true")

    @Bean
    public DataSourceProperties dataSourceProperties() {
        return new DataSourceProperties();
    }

    @Primary
    @ConditionalOnProperty(prefix = "spring.liquibase", name = "enabled", havingValue = "true")
    @Bean
    public DataSource dataSource() {
        Map<String, String> secrets = fetchSecrets(secretsManagerClient,secretDatasourceName);
        HikariDataSource hikariDataSource = new HikariDataSource();
        log.debug("Using aws secretDatasource : {} and  secretsManagerClient: {}",secretDatasourceName, secretsManagerClient);

        hikariDataSource.setJdbcUrl(springDatasourceBaseUrl+ secrets.get(DBNAME));
        log.debug("Connecting to Datasource : {} ",hikariDataSource.getJdbcUrl());
        log.debug("Secrets are available for user : {} ", secrets.get(USERNAME));

        hikariDataSource.setUsername(secrets.get(USERNAME));
        hikariDataSource.setPassword(secrets.get(PASSWORD));
        return hikariDataSource;
    }

    @ConditionalOnProperty(prefix = "spring.liquibase", name = "enabled", havingValue = "true")
    @Bean
    public SpringLiquibase SpringLiquibase() {
        Map<String, String> secrets = fetchSecrets(secretsManagerClient,secretDatasourceName);
        SpringLiquibase springLiquibase = new SpringLiquibase();
        springLiquibase.setDataSource(dataSource());
        springLiquibase.setDefaultSchema(secrets.get(DBNAME));

        springLiquibase.setChangeLog("classpath:/db/changelog/db.changelog-master.yaml");
        springLiquibase.setContexts("");
        return springLiquibase;
    }

}



--------------------
package com.rbs.bdd.application.port.in;

import org.springframework.ws.WebServiceMessage;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;

/**
 * Entry port for handling SOAP requests related to payment validation.
 * Follows hexagonal architecture's `port in` pattern.
 */
public interface CustomerRetrievalPort {
        /**
         * Validates a customer retrieval request by delegating to the underlying orchestrator/service.
         *
         * @param request The SOAP request payload.
         * @param message The outgoing WebServiceMessage to be modified and returned.
         */
        void validateCustomerRetrieval(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message);


    }

-------------------
package com.rbs.bdd.application.port.in;


import org.springframework.ws.WebServiceMessage;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;
/**
 * Entry port for handling SOAP requests related to payment validation.
 * Follows hexagonal architecture's `port in` pattern.
 */
public interface PaymentValidationPort {


    /**
     * Validates a payment arrangement request by delegating to the underlying orchestrator/service.
     *
     * @param request The SOAP request payload.
     * @param message The outgoing WebServiceMessage to be modified and returned.
     */
    void validateArrangementForPayment(ValidateArrangementForPaymentRequest request,WebServiceMessage message);



}




---------------------
package com.rbs.bdd.application.port.out;

import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;

import org.springframework.ws.WebServiceMessage;

/**
 * Defines the business contract for validating payment accounts.
 * Used by the orchestrator to call schema and business rule validators.
 */
public interface AccountValidationPort {
    /**
     * Performs XSD schema validation of the request. (Currently delegated to Spring WS config.)
     *
     * @param request The SOAP request payload.
     */
    void validateSchema(ValidateArrangementForPaymentRequest request);


    /**
     * Applies business rules on the static response XML based on request content,
     * and writes the final SOAP response directly to the output message.
     *
     * @param request The incoming SOAP request.
     * @param message The WebServiceMessage to write the modified response to.
     */
    void validateBusinessRules(ValidateArrangementForPaymentRequest request,WebServiceMessage message);

     }


--------------------
package com.rbs.bdd.application.port.out;



import org.springframework.ws.WebServiceMessage;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;


/**
 * Defines the business contract for validating payment accounts.
 * Used by the orchestrator to call schema and business rule validators.
 */
public interface RetrieveCustomerPort {
    /**
     * Performs XSD schema validation of the request. (Currently delegated to Spring WS config.)
     *
     * @param request The SOAP request payload.
     */
    void validateSchema(RetrievePrimaryCustomerForArrRequest request);


    /**
     * Applies business rules on the static response XML based on request content,
     * and writes the final SOAP response directly to the output message.
     *
     * @param request The incoming SOAP request.
     * @param message The WebServiceMessage to write the modified response to.
     */
    void retrieveCustomer(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message);

}



-----------------
package com.rbs.bdd.application.service;




import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.port.out.RetrieveCustomerPort;
import com.rbs.bdd.domain.enums.CustomerNameMapping;
import com.rbs.bdd.domain.enums.ErrorConstants;
import com.rbs.bdd.domain.enums.ServiceConstants;
import com.rbs.bdd.domain.enums.ValidationErrorType;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbs.bdd.util.ValidationUtils.RequestParams;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbs.bdd.util.ValidationUtils;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;
import jakarta.xml.soap.SOAPException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import static com.rbs.bdd.domain.enums.ServiceConstants.XPath.*;
import static com.rbs.bdd.util.ValidationUtils.generateTxnId;
import static com.rbs.bdd.util.ValidationUtils.writeResponseToSoapMessage;

/**
 * Service to handle logic for retrieving customer details based on account number.
 * Matches specific identifiers and dynamically updates SOAP XML response.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class CustomerRetrievalService implements RetrieveCustomerPort {

    private static final Logger logger = LoggerFactory.getLogger(CustomerRetrievalService.class);
    private static final String STATIC_RESPONSE_PATH = "static-response/customer-retrieval/success-response.xml";

    @Override
    public void validateSchema(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("Schema validated successfully by Spring WS.");
    }

    @Override
    public void retrieveCustomer(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message) {
        try {
            RequestParams params = extractParams(request);
            XPath xpath = XPathFactory.newInstance().newXPath();
            Document responseDoc = handleCustomerRetrieval(params, xpath);

            writeResponseToSoapMessage(message, responseDoc);
        } catch (Exception e) {
            logger.error("Customer retrieval failed", e);
            throw new AccountValidationException("Customer retrieval failed", e);
        }
    }


    private Document handleCustomerRetrieval(RequestParams params, XPath xpath) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
        Optional<ErrorDetail> error = determineCustomerRetrievalError(params);
        if (error.isPresent()) {
            Document errorDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH_FOR_CUSTOMER_RETRIEVAL);
            applyErrorResponse(errorDoc, xpath, error.get(), params.originalTxnId());
            return errorDoc;
        }

        CustomerNameMapping matched = CustomerNameMapping.fromIdentifier(params.identifier());
        if (matched != null) {
            Document responseDoc = loadAndParseXml(STATIC_RESPONSE_PATH);
            updateName(responseDoc, xpath, matched);
            logger.info("Returning matched customer response for IBAN: {}", matched.getIban());
            return responseDoc;
        }

        Document notFoundDoc = loadAndParseXml(ServiceConstants.Paths.ERROR_XML_PATH);
        applyErrorResponse(notFoundDoc, xpath, ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail(), params.originalTxnId());
        return notFoundDoc;
    }






    private void updateName(Document doc, XPath xpath, CustomerNameMapping matched) throws XPathExpressionException {
        updateText(xpath, doc, XPATH_PREFIX_TYPE, matched.getPrefixType());
        updateText(xpath, doc, XPATH_FIRST_NAME, matched.getFirstName());
        updateText(xpath, doc, XPATH_LAST_NAME, matched.getLastName());
    }

    private Optional<ErrorDetail> determineCustomerRetrievalError(RequestParams param) {

        Map<ValidationErrorType, ErrorDetail> errorMap = Map.of(
                ValidationErrorType.INVALID_PREFIX, ErrorConstants.ERR_UBAN_GB.detail(),
                ValidationErrorType.INVALID_LENGTH, ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail(),
                ValidationErrorType.INVALID_MODULUS, ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail()
        );

        return ValidationUtils.validateAccount(param, errorMap, this::isUbanValid, "CustomerRetrieval");
    }

    /**
     * Verifies if the given UBAN matches the suffix of known IBANs.
     */
    private boolean isUbanValid(String identifier) {
        return ServiceConstants.IBANs.ALL_IBANS.stream()
                .map(this::extractLast14Digits)
                .anyMatch(ibanSuffix -> ibanSuffix.equals(identifier));
    }

    /**
     * Extracts last 14 digits from a given IBAN string.
     */
    private String extractLast14Digits(String iban) {
        return iban.length() >= 14 ? iban.substring(iban.length() - 14) : "";
    }
    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail detail, String txnId) throws XPathExpressionException {
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_REF_REQUEST_TXN_ID, txnId);
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_DESCRIPTION, detail.description());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RETURN_CODE, detail.returnCode());

        if ("Unable To Complete Request".equals(detail.description())){
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_DESC, detail.systemNotificationDesc());
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_CODE, detail.returnCode());
        } else {
            Node node = (Node) xpath.evaluate(ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (Objects.nonNull(node) && Objects.nonNull(node.getParentNode())) {
                node.getParentNode().removeChild(node);
            }
        }
    }

    private void
    updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) node.setTextContent(value);
    }

    private Document loadAndParseXml(String path) throws ParserConfigurationException, IOException, SAXException {
        InputStream stream = getClass().getClassLoader().getResourceAsStream(path);
        if (Objects.isNull(stream)) {
            log.error("XML file not found at path: {}", path);
            throw new AccountValidationException("XML not found: " + path);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(stream);
    }

    private RequestParams extractParams(RetrievePrimaryCustomerForArrRequest request) {
        return new RequestParams(
                request.getArrangementIdentifier().getIdentifier(),
                request.getArrangementIdentifier().getContext().getCodeValue(),
                request.getRequestHeader().getRequestIds().get(0).getTransactionId(),
                request.getRequestHeader().getRequestIds().get(0).getSystemId()
        );
    }
   }

-------------------
Path :- resources->db.changelog-master.yaml

databaseChangeLog:
  - changeSet:
      id: initial-commit
      author: esp-simulation-service

  - include:
      file: db/changelog/rbs/customer_retrieval_request/create-customer-info-audit-tables.yaml


----------------------
Path:- resources->rbs-> customer_retrieval_request

create-customer-info-audit-tables.yaml 

databaseChangeLog:
  - changeSet:
      id: create-esp-simulation-record-table
      author: esp-simulation-service
      changes:
        - createTable:
            tableName: esp_simulation_record
            columns:
              - column:
                  name: id
                  type: UUID
                  constraints:
                    primaryKey: true
                    nullable: false
                  defaultValueComputed: gen_random_uuid()
              - column:
                  name: account_no
                  type: varchar(50)
              - column:
                  name: account_type
                  type: varchar(50)
              - column:
                  name: customer_prefix
                  type: varchar(20)
              - column:
                  name: customer_first_name
                  type: varchar(20)
              - column:
                  name: customer_last_name
                  type: varchar(20)


---------------
insert-new-rules.yaml 

databaseChangeLog:
  - changeSet:
      id: insert-esp-simulation-record-1
      author: esp-simulation-service
      changes:
        - insert:
            tableName: esp_simulation_record
            columns:
              - column:
                  name: unique_identifier
                  value: IBAN_1
              - column:
                  name: account_no
                  value: GB29NWBK60161331926801
              - column:
                  name: account_type
                  value: InternationalBankAccountNumber
              - column:
                  name: customer_prefix
                  value: MR
              - column:
                  name: customer_first_name
                  value: Alice
              - column:
                  name: customer_last_name
                  value: Johnson


  - changeSet:
      id: insert-esp-simulation-record-2
      author: esp-simulation-service
      changes:
        - insert:
            tableName: esp_simulation_record
            columns:
              - column:
                  name: account_no
                  value: GB29NWBK60161331926801
              - column:
                  name: account_type
                  value: InternationalBankAccountNumber
              - column:
                  name: customer_prefix
                  value: MRS
              - column:
                  name: customer_first_name
                  value: Alisa
              - column:
                  name: customer_last_name
                  value: Johnson


--------------------
application.properties


# These properties can be passed via system property or env variable.

# In spring cloud you can add your app properties in the bootstrap.properties file.
# Any config var specified in bootstrap.properties will be inherited by the application

# App configs in bootstrap.properties can be overridden in application.properties
spring.main.banner-mode=console
server.port=8080

# downstream endpoint
user.data.service=http://localhost:8085

spring.web.resources.static-locations=classpath:/wsdl/

logging.level.org.apache.http=DEBUG
logging.level.org.springframework.ws=DEBUG
logging.level.org.springframework.xml=DEBUG
spring.main.allow-bean-definition-overriding=true


user-service-list.restclient.max-connections=6
user-service-list.restclient.max-total-connections=6
user-service-list.restclient.connection-request-timeout.seconds=6
user-service-list.restclient.connect-timeout.seconds=6
user-service-list.restclient.socket-timeout.seconds=6

logging.level.org.springframework.ws.server.MessageTracing.sent= DEBUG
# -----------------
# actuator settings
# -----------------
management.endpoints.web.exposure.include=health,info
management.endpoints.enabled-by-default=true
management.endpoint.info.enabled=true
management.endpoint.health.enabled=true

info.app.version=@project.version@
management.info.defaults.enabled=true
management.info.git.mode=full

# Toggle whether the fail fast on missing inbound jwt, inbound jwt might be required for service if it
# is going to make a request east/west within EKS
failFastInboundJwt=false



#Aurora and Liquibase Properties
#spring.datasource.driver-class-name=org.postgresql.Driver
#spring.liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml
#spring.jpa.hibernate.ddl-auto=none



#spring.datasource.url=jdbc:postgresql://localhost:5432db.changelog-master/drools_rules
#spring.datasource.username=postgres
#spring.datasource.password=******
secret.manager.enabled=false
spring.liquibase.enabled=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

-----------------------
application-eks_dev.properties

#Aurora and Liquibase Properties
spring.datasource.base.url=jdbc:postgresql://recp-bankline-app-1-ad3f-test-aurora-db-eks-read-write-endpoint.endpoint.proxy-czuueai6m5xz.eu-west-1.rds.amazonaws.com:5432/
spring.datasource.username=*****
spring.datasource.password=*****
secret.datasource.name=runtime-dev_bdd_sandbox_dep

spring.liquibase.default-schema=*****
secret.manager.enabled=true
aws.region=eu-west-1
spring.liquibase.enabled=true
spring.liquibase.change-log='classpath:/db/changelog/db.changelog-master.yaml'


# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
