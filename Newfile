package com.rbs.bdd.application.service;


        import com.rbs.bdd.application.exception.SchemaValidationException;
        import com.rbs.bdd.infrastructure.soap.interceptor.AccountSchemaValidationInterceptor;
        import com.rbs.bdd.infrastructure.soap.interceptor.CustomerSchemaValidationInterceptor;
        import jakarta.xml.soap.MessageFactory;
        import org.junit.jupiter.api.BeforeEach;
        import org.junit.jupiter.api.DisplayName;
        import org.junit.jupiter.api.Test;
        import org.springframework.mock.web.MockHttpServletRequest;
        import org.springframework.mock.web.MockHttpServletResponse;
        import org.springframework.web.context.request.RequestContextHolder;
        import org.springframework.web.context.request.ServletRequestAttributes;
        import org.springframework.ws.WebServiceMessage;
        import org.springframework.ws.context.MessageContext;
        import org.springframework.ws.soap.saaj.SaajSoapMessage;
        import org.w3c.dom.Document;
        import org.w3c.dom.NodeList;
        import org.xml.sax.SAXParseException;

        import javax.xml.parsers.DocumentBuilderFactory;
        import java.io.ByteArrayInputStream;
        import java.io.ByteArrayOutputStream;
        import java.io.InputStream;

        import static com.rbs.bdd.domain.enums.ServiceConstants.Paths.CUSTOMER_RETRIEVAL_REQUEST;
        import static org.junit.jupiter.api.Assertions.*;
        import static org.mockito.Mockito.*;

/**
 * Unit tests for {@link CustomerRetrievalSchemaValidationInterceptorTest}, ensuring schema validation errors
 * are intercepted and custom static error SOAP responses are returned with dynamic field replacements.
 */
class CustomerRetrievalSchemaValidationInterceptorTest {

    private CustomerSchemaValidationInterceptor interceptor;

    @BeforeEach
    void setup() {
        interceptor = new CustomerSchemaValidationInterceptor();
    }

    /**
     * Tests that a custom SOAP fault is returned with HTTP 500 when schema validation fails.
     */
    @Test
    @DisplayName("Should return custom error XML response with replaced transactionId and timestamp")
    void testHandleRequestValidationErrors_customFaultReturned() throws Exception {
        // Arrange: Load request XML that includes transactionId and systemId
        InputStream requestXml = getClass().getClassLoader().getResourceAsStream(CUSTOMER_RETRIEVAL_REQUEST);
        assertNotNull(requestXml);

        ByteArrayOutputStream requestOut = new ByteArrayOutputStream();
        requestXml.transferTo(requestOut);

        WebServiceMessage webServiceMessage = new SaajSoapMessage(
                MessageFactory.newInstance().createMessage(null,
                        new ByteArrayInputStream(requestOut.toByteArray()))
        );

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(webServiceMessage);

        // Mock HTTP response and Spring context
        MockHttpServletRequest servletRequest = new MockHttpServletRequest();
        MockHttpServletResponse servletResponse = new MockHttpServletResponse();
        RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(servletRequest,servletResponse));

        // Act
        boolean result = interceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{});

        // Assert
        assertFalse(result); // false = custom SOAP sent successfully

        String responseContent = servletResponse.getContentAsString();
        System.out.println("Actual response"+responseContent);
        assertTrue(responseContent.contains("<transactionId>"), "transactionId should be injected");
        assertTrue(responseContent.contains("<systemId>ESP</systemId>")); // use actual expected value from request
        assertEquals(500, servletResponse.getStatus());
    }

    /**
     * Tests that a SchemaValidationException is thrown when static XML is missing.
     */
    @Test
    @DisplayName("Should throw SchemaValidationException when error XML is not found")
    void testHandleRequestValidationErrors_missingStaticXml() {
        // Use subclass to override file loading behavior to simulate missing file
        AccountSchemaValidationInterceptor customInterceptor = new AccountSchemaValidationInterceptor() {
            @Override
            protected InputStream getClassLoaderResource(String path) {
                return null; // simulate missing file
            }
        };

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(mock(WebServiceMessage.class));

        assertThrows(SchemaValidationException.class,
                () -> customInterceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{}));
    }

    /**
     * Tests that <refRequestIds> is removed if request doesn't contain requestIds.
     */
    @Test
    @DisplayName("Should remove <refRequestIds> if <requestIds> missing in request")
    void testRemoveRefRequestIds_whenRequestIdsMissing() throws Exception {
        // Arrange: request XML without transactionId/systemId
        String malformedXml = """
                <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
                    <soapenv:Body>
                        <testRequest></testRequest>
                    </soapenv:Body>
                </soapenv:Envelope>
                """;

        WebServiceMessage message = new SaajSoapMessage(
                MessageFactory.newInstance().createMessage(null,
                        new ByteArrayInputStream(malformedXml.getBytes()))
        );

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(message);

        MockHttpServletRequest servletRequest = new MockHttpServletRequest();
        MockHttpServletResponse servletResponse = new MockHttpServletResponse();
        RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(servletRequest,servletResponse));

        // Act
        boolean result = interceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{});

        // Assert
        assertFalse(result);
        Document responseDoc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .parse(new ByteArrayInputStream(servletResponse.getContentAsByteArray()));

        NodeList refRequestIds = responseDoc.getElementsByTagNameNS("*", "refRequestIds");
        assertEquals(0, refRequestIds.getLength(), "refRequestIds should be removed");
    }
}

-----------------------

package com.rbs.bdd.application.service;
import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.infrastructure.soap.interceptor.AccountSchemaValidationInterceptor;
import jakarta.xml.soap.MessageFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXParseException;

import javax.xml.parsers.DocumentBuilderFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for {@link AccountSchemaValidationInterceptorTest}, ensuring schema validation errors
 * are intercepted and custom static error SOAP responses are returned with dynamic field replacements.
 */
class AccountSchemaValidationInterceptorTest {

    private AccountSchemaValidationInterceptor interceptor;

    @BeforeEach
    void setup() {
        interceptor = new AccountSchemaValidationInterceptor();
    }

    /**
     * Tests that a custom SOAP fault is returned with HTTP 500 when schema validation fails.
     */
    @Test
    @DisplayName("Should return custom error XML response with replaced transactionId and timestamp")
    void testHandleRequestValidationErrors_customFaultReturned() throws Exception {
        // Arrange: Load request XML that includes transactionId and systemId
        InputStream requestXml = getClass().getClassLoader().getResourceAsStream("static-request/account-validation-request.xml");
        assertNotNull(requestXml);

        ByteArrayOutputStream requestOut = new ByteArrayOutputStream();
        requestXml.transferTo(requestOut);

        WebServiceMessage webServiceMessage = new SaajSoapMessage(
                MessageFactory.newInstance().createMessage(null,
                        new ByteArrayInputStream(requestOut.toByteArray()))
        );

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(webServiceMessage);

        // Mock HTTP response and Spring context
        MockHttpServletRequest servletRequest = new MockHttpServletRequest();
        MockHttpServletResponse servletResponse = new MockHttpServletResponse();
        RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(servletRequest,servletResponse));

        // Act
        boolean result = interceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{});

        // Assert
        assertFalse(result); // false = custom SOAP sent successfully

        String responseContent = servletResponse.getContentAsString();
        System.out.println("Actual response"+responseContent);
        assertTrue(responseContent.contains("<transactionId>"), "transactionId should be injected");
        assertTrue(responseContent.contains("<systemId>ESP</systemId>")); // use actual expected value from request
        assertEquals(500, servletResponse.getStatus());
    }

    /**
     * Tests that a SchemaValidationException is thrown when static XML is missing.
     */
    @Test
    @DisplayName("Should throw SchemaValidationException when error XML is not found")
    void testHandleRequestValidationErrors_missingStaticXml() {
        // Use subclass to override file loading behavior to simulate missing file
        AccountSchemaValidationInterceptor customInterceptor = new AccountSchemaValidationInterceptor() {
            @Override
            protected InputStream getClassLoaderResource(String path) {
                return null; // simulate missing file
            }
        };

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(mock(WebServiceMessage.class));

        assertThrows(SchemaValidationException.class,
                () -> customInterceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{}));
    }

    /**
     * Tests that <refRequestIds> is removed if request doesn't contain requestIds.
     */
    @Test
    @DisplayName("Should remove <refRequestIds> if <requestIds> missing in request")
    void testRemoveRefRequestIds_whenRequestIdsMissing() throws Exception {
        // Arrange: request XML without transactionId/systemId
        String malformedXml = """
                <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
                    <soapenv:Body>
                        <testRequest></testRequest>
                    </soapenv:Body>
                </soapenv:Envelope>
                """;

        WebServiceMessage message = new SaajSoapMessage(
               MessageFactory.newInstance().createMessage(null,
                        new ByteArrayInputStream(malformedXml.getBytes()))
        );

        MessageContext messageContext = mock(MessageContext.class);
        when(messageContext.getRequest()).thenReturn(message);

        MockHttpServletRequest servletRequest = new MockHttpServletRequest();
        MockHttpServletResponse servletResponse = new MockHttpServletResponse();
        RequestContextHolder.setRequestAttributes(new ServletRequestAttributes(servletRequest,servletResponse));

        // Act
        boolean result = interceptor.handleRequestValidationErrors(messageContext, new SAXParseException[]{});

        // Assert
        assertFalse(result);
        Document responseDoc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .parse(new ByteArrayInputStream(servletResponse.getContentAsByteArray()));

        NodeList refRequestIds = responseDoc.getElementsByTagNameNS("*", "refRequestIds");
        assertEquals(0, refRequestIds.getLength(), "refRequestIds should be removed");
    }
}


--------------------
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:crfpSP="http://com/rbsg/soa/C040PaymentManagement/CustomerRetrievalForPayment/V01/ServiceParameters/V01/">
    <soapenv:Header/>
    <soapenv:Body>
        <crfpSP:retrievePrimaryCustomerForArr>
            <requestHeader>
                <operatingBrand>NWB</operatingBrand>
                <requestIds>
                    <systemId>RequestID</systemId>
                    <transactionId>123454444</transactionId>
                </requestIds>
                <requestIds>
                    <systemId>SourceID</systemId>
                    <transactionId>ISO</transactionId>
                </requestIds>
                <cmdType>Request</cmdType>
            </requestHeader>
            <processingParameter>
                <objectReference>
                    <identifier>NWB</identifier>
                    <context>
                        <schemeName>OrganizationEnterpriseIdType</schemeName>
                        <codeValue>OperatingBrandIdentifier</codeValue>
                    </context>
                </objectReference>
            </processingParameter>
            <arrangementIdentifier>
                <identifier>${IDENTIFIER}</identifier>
                <context>
                    <schemeName>ArrangementEnterpriseIdType</schemeName>
                    <codeValue>${CODEVALUE}</codeValue>
                    <!--Optional:-->
                    <description>aslkjdslahbkjdf</description>
                </context>
                <!--Optional:-->
                <description>aslkjdslahbkjdf</description>
            </arrangementIdentifier>
        </crfpSP:retrievePrimaryCustomerForArr>
    </soapenv:Body>
</soapenv:Envelope>


-------------------


import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.server.EndpointInterceptor;

import java.io.ByteArrayOutputStream;
/**
 * Interceptor to log incoming and outgoing SOAP messages for debugging and monitoring.
 * This class logs the full request, response, and fault messages.
 */
@Slf4j
public class SoapLoggingInterceptor implements EndpointInterceptor {


    /**
     * Logs the incoming SOAP request before it reaches the endpoint.
     *
     * @param messageContext the message context containing the request
     * @param endpoint        the targeted endpoint
     * @return true to continue processing the request
     */
    @Override
    public boolean handleRequest(MessageContext messageContext, Object endpoint) {
        logMessage("SOAP Request", messageContext.getRequest());
        return true;
    }

    /**
     * Logs the outgoing SOAP response after the endpoint returns a result.
     *
     * @param messageContext the message context containing the response
     * @param endpoint        the targeted endpoint
     * @return true to continue processing the response
     */
    @Override
    public boolean handleResponse(MessageContext messageContext, Object endpoint) {
        logMessage("SOAP Response", messageContext.getResponse());
        return true;
    }

    /**
     * Logs the SOAP fault message if an exception occurs during processing.
     *
     * @param messageContext the message context containing the fault
     * @param endpoint        the targeted endpoint
     * @return true to continue processing the fault
     */
    @Override
    public boolean handleFault(MessageContext messageContext, Object endpoint) {
        logMessage("SOAP Fault", messageContext.getResponse());
        return true;
    }

    /**
     * Called after the completion of the message exchange.
     * No action is needed here, but method must be implemented.
     */
    @Override
    public void afterCompletion(MessageContext messageContext, Object endpoint, Exception ex) {
        // No action needed after completion
    }

    /**
     * Helper method to log the SOAP message by writing it to a byte array output stream.
     *
     * @param type    the type of SOAP message (Request, Response, Fault)
     * @param message the WebServiceMessage to be logged
     */
    private void logMessage(String type, org.springframework.ws.WebServiceMessage message) {
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            message.writeTo(out);  // Serialize the message to an output stream
            log.info("{}:\n{}", type, out.toString());  // Log the message content
        } catch (Exception e) {
            log.error("Error logging {} message: {}", type, e.getMessage());
        }
    }
}


---------------
Sessionsbdd-ms-esp-simulation-service > com.rbs.bdd.infrastructure.soap.api > PaymentValidationSoapAdapter.java
PaymentValidationSoapAdapter.java
package com.rbs.bdd.infrastructure.soap.api;

import com.rbs.bdd.application.port.in.CustomerRetrievalPort;
import com.rbs.bdd.application.port.in.PaymentValidationPort;

import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;
import com.rbsg.soa.c040paymentmanagement.arrvalidationforpayment.v01.ValidateArrangementForPaymentRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;
import org.springframework.ws.server.endpoint.annotation.ResponsePayload;

import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_ACCOUNT_VALIDATION;
import static com.rbs.bdd.domain.enums.ServiceConstants.Namespaces.NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL;


/**
 * SOAP endpoint adapter class for handling the `validateArrangementForPayment` operation.
 * It uses Spring WS annotations to route incoming SOAP requests to the appropriate service layer.
 */
@Slf4j
@Endpoint
public class PaymentValidationSoapAdapter {

    /**Changes for the request*/


    private final PaymentValidationPort paymentValidationPort;
    private final CustomerRetrievalPort customerRetrievalPort;

    /**
     * Constructor-based injection of the orchestrator that handles business logic.
     *
     * @param paymentValidationPort the orchestrator service
     */
    public PaymentValidationSoapAdapter(PaymentValidationPort paymentValidationPort,CustomerRetrievalPort customerRetrievalPort) {
        this.paymentValidationPort = paymentValidationPort;
        this.customerRetrievalPort = customerRetrievalPort;
    }



    /**
     * Handles the `validateArrangementForPayment` SOAP request.
     * Delegates request processing to the orchestrator which modifies the response message directly.
     *
     * @param request the SOAP request payload
     * @param context the Spring WS message context
     */
    @PayloadRoot(namespace = NAMESPACE_URI_FOR_ACCOUNT_VALIDATION, localPart = "validateArrangementForPayment")
    @ResponsePayload
    public void validateArrangementForPayment(@RequestPayload ValidateArrangementForPaymentRequest request,
                                                MessageContext context) {
        log.info("validateArrangementForPayment is called");
        WebServiceMessage response = context.getResponse();
        paymentValidationPort.validateArrangementForPayment(request, response);
         }

    /**
     * Handles the `RetrieveCustomerRequest` SOAP request.
     * Delegates request processing to the orchestrator which modifies the response message directly.
     *
     * @param request the SOAP request payload
     * @param context the Spring WS message context
     */
    @PayloadRoot(namespace = NAMESPACE_URI_FOR_CUSTOMER_RETRIEVAL, localPart = "retrievePrimaryCustomerForArr")
    @ResponsePayload
    public void validateCustomerRetrieval(@RequestPayload RetrievePrimaryCustomerForArrRequest request,
                                              MessageContext context) {
        log.info("validateCustomerRetrieval is called");
        WebServiceMessage response = context.getResponse();

        customerRetrievalPort.validateCustomerRetrieval(request, response);
    }

}
Created with JaCoCo 0.8.13.202504020838
