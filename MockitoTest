package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.port.out.CustomerRetrievalPort;
import com.rbs.bdd.common.ErrorConstants;
import com.rbs.bdd.common.ServiceConstants;
import com.rbs.bdd.domain.enums.model.ErrorDetail;
import com.rbs.bdd.generated.RetrievePrimaryCustomerForArrRequest;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.UUID;

import static com.rbs.bdd.common.ServiceConstants.ERROR_XML_PATH;

/**
 * Service implementation for handling customer retrieval requests.
 * Validates the incoming account and returns a static SOAP response if the account matches a known value.
 * If the account is not found, returns an error response using predefined MOD97 error details.
 */
@Service
@RequiredArgsConstructor
public class CustomerRetrievalService implements CustomerRetrievalPort {

    private static final Logger logger = LoggerFactory.getLogger(CustomerRetrievalService.class);
    private static final String KNOWN_CUSTOMER_ACCOUNT = "GB29NWBK60161331926801"; // Replace with real if needed
    private static final String SUCCESS_RESPONSE_PATH = "static-response/customer-retrieval/customer-retrieval.xml";

    /**
     * Logs the fact that schema validation is already handled by Spring WS.
     *
     * @param request The SOAP request object.
     */
    @Override
    public void validateSchema(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("Schema validation completed by Spring WS");
    }

    /**
     * Performs business rule validation to determine if the requested customer account exists.
     * Returns a static success response or a MOD97 error if the account is not found.
     *
     * @param request The SOAP request payload.
     * @param message The outgoing SOAP message to be modified with the result.
     */
    @Override
    public void validateBusinessRules(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message) {
        try {
            logger.info("Starting customer retrieval business rule validation.");
            String accountNumber = request.getArrangementIdentifier().getIdentifier();
            String transactionId = request.getRequestHeader().getRequestIds().get(0).getTransactionId();

            Document responseDoc;
            XPath xpath = XPathFactory.newInstance().newXPath();

            if (KNOWN_CUSTOMER_ACCOUNT.equals(accountNumber)) {
                logger.info("Customer account matched. Returning static response.");
                responseDoc = loadAndParseXml(SUCCESS_RESPONSE_PATH);
            } else {
                logger.warn("Customer account not matched. Returning MOD97 error.");
                responseDoc = loadAndParseXml(ERROR_XML_PATH);
                applyErrorResponse(responseDoc, xpath, ErrorConstants.ERR_MOD97_IBAN, transactionId);
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            TransformerFactory tf = TransformerFactory.newInstance();
            tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
            tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
            Transformer transformer = tf.newTransformer();
            transformer.transform(new DOMSource(responseDoc), new StreamResult(out));
            ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                    .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));

            logger.info("Customer response set successfully.");

        } catch (Exception ex) {
            logger.error("Error while processing customer retrieval", ex);
            throw new AccountValidationException("Customer retrieval failed", ex);
        }
    }

    /**
     * Loads and parses a static XML file from the provided path.
     *
     * @param path The path to the static XML.
     * @return The parsed Document object.
     */
    private Document loadAndParseXml(String path) throws Exception {
        logger.debug("Loading XML from path: {}", path);
        InputStream xml = getClass().getClassLoader().getResourceAsStream(path);
        if (xml == null) {
            throw new AccountValidationException("XML not found at path: " + path);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(xml);
    }

    /**
     * Updates the static error XML with error details and request transaction ID.
     *
     * @param doc           The DOM document representing the XML response.
     * @param xpath         XPath engine instance.
     * @param errorDetail   The error details to apply.
     * @param requestTxnId  The original transaction ID from the request.
     */
    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail errorDetail, String requestTxnId) throws XPathExpressionException {
        updateText(xpath, doc, ErrorConstants.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ErrorConstants.XPATH_REF_REQUEST_TXN_ID, requestTxnId);
        updateText(xpath, doc, ErrorConstants.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ErrorConstants.XPATH_CMD_DESCRIPTION, errorDetail.description);
        updateText(xpath, doc, ErrorConstants.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ErrorConstants.XPATH_RETURN_CODE, errorDetail.returnCode);

        if (errorDetail.systemNotificationDesc != null) {
            updateText(xpath, doc, ErrorConstants.XPATH_SYS_NOTIFICATION_DESC, errorDetail.systemNotificationDesc);
            updateText(xpath, doc, ErrorConstants.XPATH_SYS_NOTIFICATION_CODE, errorDetail.returnCode);
        } else {
            Node node = (Node) xpath.evaluate(ErrorConstants.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (node != null && node.getParentNode() != null) {
                node.getParentNode().removeChild(node);
                logger.debug("Removed systemNotification block as it was not applicable.");
            }
        }
        logger.info("Error XML populated with MOD97 error.");
    }

    /**
     * Updates a given XML node with a new text value.
     */
    private void updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) {
            node.setTextContent(value);
            logger.debug("Updated XML node {} with value {}", path, value);
        }
    }

    /**
     * Generates a unique transaction ID.
     */
    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }
}
