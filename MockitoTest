package com.rbs.bdd.util;

import com.rbs.bdd.application.exception.SchemaValidationException;
import com.rbs.bdd.application.exception.XsdSchemaLoadingException;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;
import org.springframework.xml.xsd.XsdSchemaCollection;
import org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static com.rbs.bdd.domain.enums.ServiceConstants.Paths.SCHEMA_VALIDATION_ERROR_XML;
import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.SYSTEM_ID;
import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.TAG_TRANSACTION_ID;

@Slf4j
public class SoapInterceptorUtils {
    private SoapInterceptorUtils(){}


    private static final String PLACEHOLDER_TXN = "TXN_ID_PLACEHOLDER";
    private static final String PLACEHOLDER_RESPONSE = "RESPONSE_ID_PLACEHOLDER";


    /**
     * Retrieves the text content of a given tag from the request document.
     */
    public static String getValueFromRequest(Document doc, String tag) {
        NodeList list = doc.getElementsByTagNameNS("*", tag);
        return list.getLength() > 0 ? list.item(0).getTextContent() : null;
    }

    /**
     * Finds a node by its local name using wildcard namespace.
     */
    public static Node getNode(Document doc, String localName) {
        NodeList nodes = doc.getElementsByTagNameNS("*", localName);
        return nodes.getLength() > 0 ? nodes.item(0) : null;
    }

    /**
     * Replaces a text node matching a placeholder with a new value.
     */
    public static void replaceTextNode(Document doc, String placeholder, String newValue) {
        NodeList nodes = doc.getElementsByTagNameNS("*", TAG_TRANSACTION_ID);
        for (int i = 0; i < nodes.getLength(); i++) {
            Node txn = nodes.item(i);
            if (placeholder.equals(txn.getTextContent())) {
                txn.setTextContent(newValue);
            }
        }
    }

    /**
     * Sends the final SOAP error response with HTTP 500.
     */
    public static void sendCustomSoapFault(Document errorDoc) throws TransformerException, IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD,"");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,"");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(errorDoc), new StreamResult(out));

        HttpServletResponse servletResponse =
                ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getResponse();

        if (servletResponse != null && !servletResponse.isCommitted()) {
            servletResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            servletResponse.setContentType("text/xml;charset=UTF-8");
            servletResponse.getOutputStream().write(out.toByteArray());
            servletResponse.flushBuffer();
        }
    }

    /**
     * Creates a secure, namespace-aware {@link DocumentBuilderFactory}.
     * <p>
     * This method disables external entity processing to prevent XML External Entity (XXE)
     * attacks and other injection vulnerabilities.
     *
     *
     * @return configured {@link DocumentBuilderFactory} instance
     * @throws ParserConfigurationException if security features cannot be set
     */
    public static DocumentBuilder getSecureDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setXIncludeAware(false);
        factory.setExpandEntityReferences(false);
        return factory.newDocumentBuilder();
    }


    public static boolean skipInterceptorIfNamespaceNotMatched(MessageContext messageContext, String expectedNamespace) {
        try {
            WebServiceMessage request = messageContext.getRequest();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            request.writeTo(out);
            String xml =out.toString();

            if (!xml.contains(expectedNamespace)) {
                return true;
            }
        } catch (Exception e) {
            log.error("Error in namespace filtering", e);
        }
        return false;
    }

    /**
     * Checks if the given node is empty or only contains non-element children.
     */
    public static boolean isNodeEmpty(Node node) {
        if (node == null) return true;
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) return false;
        }
        return true;
    }

    /**
     * Removes a specific child element from the parent node.
     */
    public static void removeNode(Node parent, String tagName) {
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    public static XsdSchemaCollection loadSchema(String path)
    {
        try {
            CommonsXsdSchemaCollection xsd = new CommonsXsdSchemaCollection(
                    new ClassPathResource(path));
            xsd.setInline(true);
            return xsd;
        } catch (Exception e) {
            throw new XsdSchemaLoadingException("Failed to load XSD schema for SOAP validation", e);
        }
    }

    public static DefaultWsdl11Definition buildWsdlDefinition(String beanName, String portType, String namespace, XsdSchemaCollection schemaCollection)
    {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName(portType);
        wsdl11Definition.setLocationUri("/ws");
        wsdl11Definition.setTargetNamespace(namespace);
        wsdl11Definition.setSchemaCollection(schemaCollection);

        return wsdl11Definition;
    }

    /**
     * Parses the incoming request message into a Document.
     */
    public static Document extractRequestDocument(MessageContext messageContext, DocumentBuilder builder) throws IOException, SAXException {
        WebServiceMessage request = messageContext.getRequest();
        ByteArrayOutputStream requestBytes = new ByteArrayOutputStream();
        request.writeTo(requestBytes);
        return builder.parse(new ByteArrayInputStream(requestBytes.toByteArray()));
    }

    /**
     * Sets a value for the node matching the given XPath expression.
     */
    public static void setXPathValue(Document doc, String path, String value) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent(value);
        }
    }

    /**
     * Handles schema validation failures by generating a custom SOAP fault response.
     * Modifies a static error XML template based on the request content and sends it with HTTP 500.
     *
     * @param messageContext the message context
     * @return false to prevent Spring WS from overriding with default fault
     */

    public static boolean handleSchemaValidationErrors(MessageContext messageContext, String errorPath, String filter) {
        log.warn("Schema validation failed. Returning custom schemaValidationError.xml");

        try (InputStream staticXml = SoapInterceptorUtils.class.getClassLoader().getResourceAsStream(errorPath)) {
            if (staticXml == null) {
                log.error("schemaValidationError.xml not found");
                return true;
            }

            DocumentBuilder builder = SoapInterceptorUtils.getSecureDocumentBuilder();
            Document errorDoc = builder.parse(staticXml);
            Document requestDoc = SoapInterceptorUtils.extractRequestDocument(messageContext, builder);
            if(filter.equals("accountValidation")){
                updateDynamicFields(errorDoc, requestDoc);}
            else{
                updateFields(errorDoc, requestDoc);
            }

            SoapInterceptorUtils.sendCustomSoapFault(errorDoc);
            return false;
        } catch (Exception e) {
            log.error("Error during schema validation interception", e);
            throw new SchemaValidationException("Schema validation failure", e);
        }
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private static void updateDynamicFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        String txnId = SoapInterceptorUtils.getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        String systemId = SoapInterceptorUtils.getValueFromRequest(requestDoc, SYSTEM_ID);

        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        SoapInterceptorUtils.setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));

        handleRefRequestIds(errorDoc, requestDoc, txnId, systemId);
    }

    /**
     * Handles removal of <refRequestIds> node if <requestIds> is missing or empty.
     */
    private static void handleRefRequestIds(Document errorDoc, Document requestDoc, String txnId, String systemId) {
        Node requestIds = SoapInterceptorUtils.getNode(requestDoc, "requestIds");
        boolean isEmpty = SoapInterceptorUtils.isNodeEmpty(requestIds);

        Node refRequestIds = SoapInterceptorUtils.getNode(errorDoc, "refRequestIds");

        if (isEmpty  && refRequestIds != null) {
            refRequestIds.getParentNode().removeChild(refRequestIds);
            return;
        }

        if (refRequestIds != null) {
            if (txnId == null) SoapInterceptorUtils.removeNode(refRequestIds, TAG_TRANSACTION_ID);
            if (systemId == null) SoapInterceptorUtils.removeNode(refRequestIds, SYSTEM_ID);
            if (!refRequestIds.hasChildNodes()) {
                refRequestIds.getParentNode().removeChild(refRequestIds);
            }
        }
    }

    /**
     * Updates transaction ID, timestamp, and cleans up the response XML dynamically.
     */
    private static void updateFields(Document errorDoc, Document requestDoc) throws XPathExpressionException {
        String txnId = SoapInterceptorUtils.getValueFromRequest(requestDoc, TAG_TRANSACTION_ID);
        SoapInterceptorUtils.replaceTextNode(errorDoc, PLACEHOLDER_RESPONSE, generateTxnId());
        SoapInterceptorUtils. replaceTextNode(errorDoc, PLACEHOLDER_TXN, txnId != null ? txnId : PLACEHOLDER_TXN);
        SoapInterceptorUtils.setXPathValue(errorDoc, "//*[local-name()='timestamp']",
                OffsetDateTime.now(ZoneId.of("Europe/London")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));

        handleRequestIds(errorDoc, requestDoc);
    }

    /**
     * Handles removal of {@code <refRequestIds>} node if {@code  <requestIds> }is missing or empty.
     */
    public static void handleRequestIds(Document errorDoc, Document requestDoc) {
        NodeList requestIdNodes = requestDoc.getElementsByTagNameNS("*", "requestIds");
        Node refRequestIds = SoapInterceptorUtils.getNode(errorDoc, "refRequestIds");

        boolean foundRequestIDSystemId = false;
        boolean hasTxnId = false;
        boolean hasSystemId = false;

        for (int i = 0; i < requestIdNodes.getLength(); i++) {
            Node requestIdsNode = requestIdNodes.item(i);
            NodeList children = requestIdsNode.getChildNodes();

            String currentSystemId = null;
            boolean txnIdPresent = false;
            boolean systemIdPresent = false;

            for (int j = 0; j < children.getLength(); j++) {
                Node child = children.item(j);
                if (SYSTEM_ID.equals(child.getLocalName())) {
                    currentSystemId = child.getTextContent();
                    systemIdPresent = true;
                } else if (TAG_TRANSACTION_ID.equals(child.getLocalName())) {
                    txnIdPresent = true;
                }
            }

            if ("RequestID".equals(currentSystemId)) {
                foundRequestIDSystemId = true;
                hasTxnId = txnIdPresent;
                hasSystemId = systemIdPresent;
                break;
            }
        }

        if (refRequestIds != null) {
            if (!foundRequestIDSystemId) {
                // No matching <requestIds> with systemId=RequestID â†’ remove entire block
                refRequestIds.getParentNode().removeChild(refRequestIds);
            } else {
                // Remove missing child nodes
                if (!hasTxnId) SoapInterceptorUtils.removeNode(refRequestIds, TAG_TRANSACTION_ID);
                if (!hasSystemId) SoapInterceptorUtils.removeNode(refRequestIds, SYSTEM_ID);

                // If nothing left inside, remove the entire block
                if (!refRequestIds.hasChildNodes()) {
                    refRequestIds.getParentNode().removeChild(refRequestIds);
                }
            }
        }
    }

    /**
     * Generates a unique transaction ID using UUID.
     */
    public static String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

}
