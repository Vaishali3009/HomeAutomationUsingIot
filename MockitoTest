package com.rbs.bdd.util;

import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXParseException;
import org.springframework.ws.context.MessageContext;
import org.springframework.ws.WebServiceMessage;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;/**
     * Handles removal of {@code <refRequestIds>} node if {@code  <requestIds> }is missing or empty.
     */
    public static void handleRequestIds(Document errorDoc, Document requestDoc) {
        NodeList requestIdNodes = requestDoc.getElementsByTagNameNS("*", "requestIds");
        Node refRequestIds = SoapInterceptorUtils.getNode(errorDoc, "refRequestIds");

        boolean foundRequestIDSystemId = false;
        boolean hasTxnId = false;
        boolean hasSystemId = false;

        for (int i = 0; i < requestIdNodes.getLength(); i++) {
            Node requestIdsNode = requestIdNodes.item(i);
            NodeList children = requestIdsNode.getChildNodes();

            String currentSystemId = null;
            boolean txnIdPresent = false;
            boolean systemIdPresent = false;

            for (int j = 0; j < children.getLength(); j++) {
                Node child = children.item(j);
                if (SYSTEM_ID.equals(child.getLocalName())) {
                    currentSystemId = child.getTextContent();
                    systemIdPresent = true;
                } else if (TAG_TRANSACTION_ID.equals(child.getLocalName())) {
                    txnIdPresent = true;
                }
            }

            if ("RequestID".equals(currentSystemId)) {
                foundRequestIDSystemId = true;
                hasTxnId = txnIdPresent;
                hasSystemId = systemIdPresent;
                break;
            }
        }

        if (refRequestIds != null) {
            if (!foundRequestIDSystemId) {
                // No matching <requestIds> with systemId=RequestID â†’ remove entire block
                refRequestIds.getParentNode().removeChild(refRequestIds);
            } else {
                // Remove missing child nodes
                if (!hasTxnId) SoapInterceptorUtils.removeNode(refRequestIds, TAG_TRANSACTION_ID);
                if (!hasSystemId) SoapInterceptorUtils.removeNode(refRequestIds, SYSTEM_ID);

                // If nothing left inside, remove the entire block
                if (!refRequestIds.hasChildNodes()) {
                    refRequestIds.getParentNode().removeChild(refRequestIds);
                }
            }
        }
    }
import javax.xml.xpath.XPathFactory;
import java.io.InputStream;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.SYSTEM_ID;
import static com.rbs.bdd.domain.enums.ServiceConstants.Tags.TAG_TRANSACTION_ID;

@Slf4j
@UtilityClass
public class SoapInterceptorUtils {

    /**
     * Handles removal of <refRequestIds> node based on the content of <requestIds> in the request.
     *
     * @param errorDoc   the static error response document
     * @param requestDoc the incoming request document
     */
    public static void handleRequestIds(Document errorDoc, Document requestDoc) {
        NodeList requestIdNodes = requestDoc.getElementsByTagNameNS("*", "requestIds");
        Node refRequestIds = getNode(errorDoc, "refRequestIds");

        ValidationFlags flags = findRequestIdFlags(requestIdNodes);

        if (refRequestIds != null) {
            if (!flags.foundRequestIDSystemId()) {
                removeNode(refRequestIds);
            } else {
                removeMissingChildNodes(refRequestIds, flags);
            }
        }
    }

    /**
     * Checks if any <requestIds> contains systemId="RequestID" and extracts presence of sub-elements.
     *
     * @param requestIdNodes list of requestIds nodes
     * @return flags object containing presence indicators for systemId and transactionId
     */
    private static ValidationFlags findRequestIdFlags(NodeList requestIdNodes) {
        for (int i = 0; i < requestIdNodes.getLength(); i++) {
            Node requestIdsNode = requestIdNodes.item(i);
            NodeList children = requestIdsNode.getChildNodes();

            String systemId = null;
            boolean txnIdPresent = false;
            boolean systemIdPresent = false;

            for (int j = 0; j < children.getLength(); j++) {
                Node child = children.item(j);
                String tag = child.getLocalName();

                if (SYSTEM_ID.equals(tag)) {
                    systemId = child.getTextContent();
                    systemIdPresent = true;
                } else if (TAG_TRANSACTION_ID.equals(tag)) {
                    txnIdPresent = true;
                }
            }

            if ("RequestID".equals(systemId)) {
                return new ValidationFlags(true, txnIdPresent, systemIdPresent);
            }
        }
        return new ValidationFlags(false, false, false);
    }

    /**
     * Removes specific child tags from <refRequestIds> node if they were missing in request.
     *
     * @param refRequestIds the target <refRequestIds> node in error document
     * @param flags         presence indicators for required fields
     */
    private static void removeMissingChildNodes(Node refRequestIds, ValidationFlags flags) {
        if (!flags.hasTxnId()) {
            removeNode(refRequestIds, TAG_TRANSACTION_ID);
        }
        if (!flags.hasSystemId()) {
            removeNode(refRequestIds, SYSTEM_ID);
        }
        if (!refRequestIds.hasChildNodes()) {
            removeNode(refRequestIds);
        }
    }

    /**
     * Removes the specified child node from the parent node.
     *
     * @param parentNode  the parent node
     * @param childTagName name of the child tag to remove
     */
    public static void removeNode(Node parentNode, String childTagName) {
        NodeList children = parentNode.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (childTagName.equals(child.getLocalName())) {
                parentNode.removeChild(child);
                break;
            }
        }
    }

    /**
     * Removes a node from its parent if present.
     *
     * @param node the node to remove
     */
    public static void removeNode(Node node) {
        if (node != null && node.getParentNode() != null) {
            node.getParentNode().removeChild(node);
        }
    }

    /**
     * Extracts a single node by tag name using XPath.
     *
     * @param doc the XML document
     * @param tag the tag name
     * @return matching node or null
     */
    public static Node getNode(Document doc, String tag) {
        try {
            XPath xpath = XPathFactory.newInstance().newXPath();
            return (Node) xpath.evaluate("//*[local-name()='" + tag + "']", doc, XPathConstants.NODE);
        } catch (Exception e) {
            log.error("Error while retrieving node: {}", tag, e);
            return null;
        }
    }

    /**
     * Generates a UUID-based response ID.
     *
     * @return unique ID
     */
    public static String generateResponseId() {
        return "RSP-" + UUID.randomUUID().toString().replace("-", "").substring(0, 16);
    }

    /**
     * Returns the current timestamp in ISO_OFFSET_DATE_TIME format.
     *
     * @return timestamp string
     */
    public static String getCurrentTimestamp() {
        return OffsetDateTime.now(ZoneId.of("UTC")).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
    }

    /**
     * Parses a SOAP message body into a DOM Document.
     *
     * @param message SOAP message
     * @return DOM Document
     */
    public static Document parseMessage(WebServiceMessage message) {
        try {
            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
            return builder.parse(message.getPayloadSource().getInputStream());
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse SOAP message", e);
        }
    }

    /**
     * Validates whether to skip the interceptor based on target namespace.
     *
     * @param messageContext Message context
     * @param targetNamespace target URI to match
     * @return true if should skip
     */
    public static boolean skipInterceptorIfNamespaceNotMatched(MessageContext messageContext, String targetNamespace) {
        try {
            Document doc = parseMessage(messageContext.getRequest());
            String namespace = doc.getDocumentElement().getNamespaceURI();
            return !targetNamespace.equals(namespace);
        } catch (Exception e) {
            log.warn("Failed to determine namespace from request", e);
            return true; // Skip if unsure
        }
    }

    /**
     * A small container record for requestId validation flags.
     */
    private record ValidationFlags(boolean foundRequestIDSystemId, boolean hasTxnId, boolean hasSystemId) {}
}
