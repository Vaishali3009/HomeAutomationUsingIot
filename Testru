package com.rbs.bdd.application.service;




import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.exception.CustomerRetrievalException;
import com.rbs.bdd.application.port.out.RetrieveCustomerPort;
import com.rbs.bdd.common.context.TransactionIdContext;
import com.rbs.bdd.domain.enums.CustomerNameMapping;
import com.rbs.bdd.domain.enums.ErrorConstants;
import com.rbs.bdd.domain.enums.ServiceConstants;
import com.rbs.bdd.domain.enums.ValidationErrorType;
import com.rbs.bdd.domain.model.ErrorDetail;
import com.rbs.bdd.infrastructure.entity.CustomerData;
import com.rbs.bdd.infrastructure.repository.CustomerRepository;
import com.rbs.bdd.util.ValidationUtils.RequestParams;
import com.rbs.bdd.util.ValidationUtils;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.RetrievePrimaryCustomerForArrRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import static com.rbs.bdd.domain.enums.ServiceConstants.Paths.STATIC_RESPONSE_PATH;
import static com.rbs.bdd.domain.enums.ServiceConstants.XPath.*;
import static com.rbs.bdd.util.ValidationUtils.generateTxnId;
import static com.rbs.bdd.util.ValidationUtils.writeResponseToSoapMessage;

/**
 * Service to handle logic for retrieving customer details based on account number.
 * Matches specific identifiers and dynamically updates SOAP XML response.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class CustomerRetrievalService implements RetrieveCustomerPort {

    private final CustomerRepository repository;

    private static final Logger logger = LoggerFactory.getLogger(CustomerRetrievalService.class);

    @Override
    public void validateSchema(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("TransactionID: {},Message: Schema validated successfully by Spring WS.",getTransactionId());
    }

    @Override
    public void retrieveCustomer(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message) {
        try {
            logger.info("TransactionID: {},Message: Entered in retrieveCustomer.",getTransactionId());
            RequestParams params = extractParams(request);
            XPath xpath = XPathFactory.newInstance().newXPath();
            Document responseDoc = handleCustomerRetrieval(params, xpath);

            writeResponseToSoapMessage(message, responseDoc);
        } catch (Exception e) {
            logger.error("TransactionID: {},Message: Customer retrieval failed",getTransactionId(), e);
            throw new CustomerRetrievalException("Customer retrieval failed", e);
        }
    }


    private String getTransactionId(){
        return TransactionIdContext.get();
    }

    private Document handleCustomerRetrieval(RequestParams params, XPath xpath) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
        logger.debug("TransactionID: {},Message: Handle Customer Retrieval",getTransactionId());
        Optional<ErrorDetail> error = determineCustomerRetrievalError(params);
        if (error.isPresent()) {
            return buildErrorResponse(error.get(), xpath, params.originalTxnId(),
                    ServiceConstants.Paths.ERROR_XML_PATH_FOR_CUSTOMER_RETRIEVAL);}
        // 1. Try DB match
        Optional<CustomerData> dbResult = repository.findByAccountNo(params.identifier());
        if (dbResult.isPresent() && dbResult.get().getAccountType().equals(params.codeValue())) {
            logger.info("TransactionID: {},Message: Account matched in DB for IBAN: {}",getTransactionId(), params.identifier());
            CustomerInfo customer = new CustomerInfo(dbResult.get().getPrefixType(),
                    dbResult.get().getFirstName(),
                    dbResult.get().getLastName());
            return buildSuccessResponse(xpath, customer);}
        // 2. Try hardcoded account match
        CustomerNameMapping matched = CustomerNameMapping.fromIdentifier(params.identifier());
        if (matched != null) {
            logger.info("TransactionID: {},Message: Account matched in config list for IBAN: {}",getTransactionId(), params.identifier());
            CustomerInfo customer = new CustomerInfo(
                    matched.getPrefixType(),
                    matched.getFirstName(),
                    matched.getLastName());
            return buildSuccessResponse(xpath, customer);}
        // 3. Nothing matched
        logger.error("TransactionID: {},Message: Customer Not Found for IBAN: {}",getTransactionId(), params.identifier());
        return buildErrorResponse(ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail(), xpath, params.originalTxnId(),
                ServiceConstants.Paths.ACCOUNT_VALIDATION_ERROR_XML);}

    private Document buildSuccessResponse(XPath xpath, CustomerInfo customer) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
        log.info("TransactionID: {},Message: Entered in buildSuccessResponse",getTransactionId());
        Document responseDoc = loadAndParseXml(STATIC_RESPONSE_PATH);
        updateName(responseDoc, xpath, customer);
        return responseDoc;
    }

    private Document buildErrorResponse(ErrorDetail errorDetail, XPath xpath, String txnId, String errorXmlPath) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {
        log.info("Building the Error Response ",getTransactionId());
        Document errorDoc = loadAndParseXml(errorXmlPath);
        applyErrorResponse(errorDoc, xpath, errorDetail, txnId);
        return errorDoc;
    }

    private void updateName(Document doc, XPath xpath, CustomerInfo customerData) throws XPathExpressionException {
        log.info("TransactionID: {},Message: Setting the Customer Name information in the response",getTransactionId());
        updateText(xpath, doc, XPATH_PREFIX_TYPE, customerData.prefixType());
        updateText(xpath, doc, XPATH_FIRST_NAME, customerData.firstName);
        updateText(xpath, doc, XPATH_LAST_NAME, customerData.lastName());
    }

    private Optional<ErrorDetail> determineCustomerRetrievalError(RequestParams param) {
        log.info("TransactionID: {},Message: Entered in determineCustomerRetrievalError",getTransactionId());
        Map<ValidationErrorType, ErrorDetail> errorMap = Map.of(
                ValidationErrorType.INVALID_PREFIX, ErrorConstants.ERR_UBAN_GB.detail(),
                ValidationErrorType.INVALID_LENGTH, ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail(),
                ValidationErrorType.INVALID_MODULUS, ErrorConstants.ERR_CUSTOMER_NOT_FOUND.detail()
        );

        return ValidationUtils.validateAccount(param, errorMap, this::isUbanValid, "CustomerRetrieval");
    }

    /**
     * Verifies if the given UBAN matches the suffix of known IBANs.
     */
    private boolean isUbanValid(String identifier) {
        log.info("TransactionID: {},Message: Validating the UBAN",getTransactionId());
        return ServiceConstants.IBANs.ALL_IBANS.stream()
                .map(this::extractLast14Digits)
                .anyMatch(ibanSuffix -> ibanSuffix.equals(identifier));
    }

    /**
     * Extracts last 14 digits from a given IBAN string.
     */
    private String extractLast14Digits(String iban) {
        log.info("TransactionID: {},Message: Entered in extractLast14Digits ",getTransactionId());
        return iban.length() >= 14 ? iban.substring(iban.length() - 14) : "";
    }
    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail detail, String txnId) throws XPathExpressionException {
        log.info("TransactionID: {},Message: Entered in applyErrorResponse",getTransactionId());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_REF_REQUEST_TXN_ID, txnId);
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_CMD_DESCRIPTION, detail.description());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ServiceConstants.XPath.XPATH_RETURN_CODE, detail.returnCode());

        if ("Customer Not Found".equals(detail.systemNotificationDesc())){
            log.error("TransactionID: {},Message: Error occured :" + detail.systemNotificationDesc(),getTransactionId());
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_DESC, detail.systemNotificationDesc());
            updateText(xpath, doc, ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_CODE, detail.systemNotificationCode());
        } else {
            log.error("TransactionID: {},Message: Error occured :" + detail.description(),getTransactionId());
            Node node = (Node) xpath.evaluate(ServiceConstants.XPath.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (Objects.nonNull(node) && Objects.nonNull(node.getParentNode())) {
                node.getParentNode().removeChild(node);
            }
        }
    }

    private void
    updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) node.setTextContent(value);
    }

    private Document loadAndParseXml(String path) throws ParserConfigurationException, IOException, SAXException {
        log.info("TransactionID: {},Message: Loading the SOAP Request ",getTransactionId());
        InputStream stream = getClass().getClassLoader().getResourceAsStream(path);
        if (Objects.isNull(stream)) {
            log.error("TransactionID: {},Message: XML file not found at path: {}",getTransactionId(), path);
            throw new CustomerRetrievalException("XML not found: " + path);
        }

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(stream);
    }

    private RequestParams extractParams(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("TransactionID: {},Message: Extract Params from request ",getTransactionId());
        return new RequestParams(
                request.getArrangementIdentifier().getIdentifier(),
                request.getArrangementIdentifier().getContext().getCodeValue(),
                request.getRequestHeader().getRequestIds().get(0).getTransactionId(),
                request.getRequestHeader().getRequestIds().get(0).getSystemId()
        );
    }
    /**
     * Immutable container representing a valid request configuration.
     * this record is left without methods or additional logic,as it is only
     *  used to group and transport request fields such as
     *  <ul>
     *     <li>{@code identifier} - contains account number </li>
     *     <li>{@code codeValue} - used to identify
     * whether account is UKBasicBankAccountNumber or InternationalBankAccountNumber</li>
     *      <li>{@code originalTxnId} - return the transactionId of the request </li>
     *       <li>{@code systemId} - returns the systemId from the request </li>
     *       </ul>
     */
    @SuppressWarnings("unused")
    public record CustomerInfo(String prefixType, String firstName, String lastName) {
        // this record is left without methods or additional logic,as it is only used to group and transport request fields

    }
   }


-----------------
package com.rbs.bdd.util;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Predicate;

import com.rbs.bdd.application.service.AccountValidationService;
import com.rbs.bdd.domain.enums.ServiceConstants;
import com.rbs.bdd.domain.enums.ValidationErrorType;
import com.rbs.bdd.domain.model.ErrorDetail;
import jakarta.xml.soap.SOAPException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.XMLConstants;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

/**
 * Utility class for validating account identifiers like IBAN or UBAN
 * across different service contexts such as Account Validation or Customer Retrieval.
 * <p>
 * This class centralizes error evaluation logic based on account type, identifier format,
 * length, and modulus check results.
 */
@Slf4j
public class ValidationUtils {
    /**
     * Immutable container representing a valid request configuration.
     * this record is left without methods or additional logic,as it is only
     *  used to group and transport request fields such as
     *  <ul>
     *     <li>{@code identifier} - contains account number </li>
     *     <li>{@code codeValue} - used to identify
     * whether account is UKBasicBankAccountNumber or InternationalBankAccountNumber</li>
     *      <li>{@code originalTxnId} - return the transactionId of the request </li>
     *       <li>{@code systemId} - returns the systemId from the request </li>
     *       </ul>
     */
    @SuppressWarnings("unused")
    public record RequestParams(String identifier, String codeValue, String originalTxnId, String systemId) {
        // this record is left without methods or additional logic,as it is only used to group and transport request fields

    }


    /**
     * Checks if the given node is empty or only contains non-element children.
     */
    public static boolean isNodeEmpty(Node node) {
        if (node == null) return true;
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.ELEMENT_NODE) return false;
        }
        return true;
    }

    /**
     * Removes a specific child element from the parent node.
     */
    public static void removeNodes(Node parent, String tagName) {
        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Validates the provided {@link RequestParams} based on predefined rules for
     * account type (UK Basic or International) and returns a mapped {@link ErrorDetail}
     * from the provided {@code errorMap} based on failure conditions.
     * <p>
     * This method is reusable across multiple services and logs the validation
     * outcome per service context.
     * @param p              the request parameter object containing account details
     * @param errorMap       a mapping of {@link ValidationErrorType} to corresponding {@link ErrorDetail}
     * @param ibanValidator  a predicate used to validate IBAN or UBAN using modulus or custom rule
     * @param serviceContext a string to log the calling service (e.g., "AccountValidation", "CustomerRetrieval")
     * @return an {@code Optional<ErrorDetail>} containing the matched error if validation fails; empty otherwise
     */
    public static Optional<ErrorDetail> validateAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            Predicate<String> ibanValidator,
            String serviceContext
    ) {
        if (ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT.equals(p.codeValue())) {
            log.info("Account Type is :"+ ServiceConstants.AccountTypes.UK_BASIC_BANK_ACCOUNT);
            return validateUbanAccount(p, errorMap, ibanValidator, serviceContext);
        }

        if (ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT.equals(p.codeValue())) {
            log.info("Account Type is :"+ServiceConstants.AccountTypes.INTL_BANK_ACCOUNT);
            return validateIbanAccount(p, errorMap, serviceContext);
        }

        return Optional.empty();
    }

    /**
     * Validates a UK Basic Bank Account (UBAN).
     */
    private static Optional<ErrorDetail> validateUbanAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            Predicate<String> ibanValidator,
            String context
    ) {
        log.error("Entered in validateUbanAccount ");
        if (!p.identifier().matches("\\d+")) {
            log.error("UBAN account is starting with GB prefix");
            return Optional.of(errorMap.get(ValidationErrorType.INVALID_PREFIX));
        }

        if (p.identifier().length() != 14) {
            log.error("UBAN account is not equal to 14 characters");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_LENGTH)
                    : errorMap.get(ValidationErrorType.INVALID_UBAN_LENGTH));
        }

        if (!ibanValidator.test(p.identifier())) {
            log.error("UBAN account is not valid");
            return Optional.of(errorMap.get(ValidationErrorType.INVALID_MODULUS));
        }

        log.info("No error for UBAN [{}] in {} with identifier: {}", p.codeValue(), context, p.identifier());
        return Optional.empty();
    }

    /**
     * Validates an International Bank Account Number (IBAN).
     */
    private static Optional<ErrorDetail> validateIbanAccount(
            RequestParams p,
            Map<ValidationErrorType, ErrorDetail> errorMap,
            String context
    ) {

        if (!p.identifier().startsWith("GB")) {
            log.error("IBAN account is not starting with GB prefix");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_PREFIX)
                    : errorMap.get(ValidationErrorType.INVALID_COUNTRY_CODE));
        }

        if (p.identifier().length() != 22) {
            log.error("IBAN account is not equal to 22 characters");
            return Optional.of(context.equals("CustomerRetrieval")
                    ? errorMap.get(ValidationErrorType.INVALID_LENGTH)
                    : errorMap.get(ValidationErrorType.INVALID_IBAN_LENGTH));

        }

        log.info("No error for IBAN [{}] in {} with identifier: {}", p.codeValue(), context, p.identifier());
        return Optional.empty();
    }




    /**
     * Generates a unique transaction ID using UUID.
     */
    public static String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }
    /**
     * Removes a child node from the specified parent node.
     * <ul>
     *     <li>If {@code tagName} is {@code null}, it removes the node directly from its parent.</li>
     *     <li>If {@code tagName} is provided, it searches the children of the parent node and removes the first match based on local name.</li>
     * </ul>
     *
     * @param parentOrNode the node to be removed directly (if {@code tagName} is null), or parent node (if tagName is provided)
     * @param tagName       the local name of the child node to remove; {@code null} for direct removal
     */
    public static void removeChildNode(Node parentOrNode, String tagName) {
        if (tagName == null) {
            removeDirectNode(parentOrNode);
        } else {
            removeChildByTag(parentOrNode, tagName);
        }
    }

    /**
     * Sets a value for the node matching the given XPath expression.
     */
    public static void setXPathValue(Document doc, String path, String value) throws XPathExpressionException {
        XPath xpath = XPathFactory.newInstance().newXPath();
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null) {
            node.setTextContent(value);
        }
    }

    /**
     * Removes the given node from its parent if both are non-null.
     */
    private static void removeDirectNode(Node node) {
        if (node != null && node.getParentNode() != null) {
            node.getParentNode().removeChild(node);
        }
    }

    /**
     * Removes the first child of the parent that matches the given local tag name.
     */
    private static void removeChildByTag(Node parent, String tagName) {
        if (parent == null || tagName == null) return;

        NodeList children = parent.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            if (tagName.equals(child.getLocalName())) {
                parent.removeChild(child);
                break;
            }
        }
    }

    /**
     * Finds a node by its local name using wildcard namespace.
     */
    public static Node getNode(Document doc, String localName) {
        NodeList nodes = doc.getElementsByTagNameNS("*", localName);
        return nodes.getLength() > 0 ? nodes.item(0) : null;
    }

    public static  void writeResponseToSoapMessage(WebServiceMessage message, Document responseDoc) throws TransformerException, SOAPException {
        log.info("Entered in writeResponseToSoapMessage");
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(new DOMSource(responseDoc), new StreamResult(out));
        ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));
    }



}

-----
package com.rbs.bdd.domain.enums;

/**
 * Enum to map known IBANs to first and last customer names.
 */
public enum CustomerNameMapping {

    IBAN_1("GB29NWBK60161331926801", "Alice", "Johnson","MR"),
    IBAN_2("GB82WEST12345698765437", "Bob", "Williams","MR"),
    IBAN_3("GB94BARC10201530093422", "Jenifer", "Brown","MRS"),
    IBAN_4("GB33BUKB20201555555567", "Jenny", "Smith","MRS");

    private final String iban;
    private final String firstName;
    private final String lastName;

    private final String prefixType;

    CustomerNameMapping(String iban, String firstName, String lastName,String prefixType) {
        this.iban = iban;
        this.firstName = firstName;
        this.lastName = lastName;
        this.prefixType=prefixType;
    }

    public String getIban() {
        return iban;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }
    public String getPrefixType() {
        return prefixType;
    }

    public static CustomerNameMapping fromIdentifier(String identifier) {
        for (CustomerNameMapping mapping : values()) {
            if (mapping.iban.equals(identifier) ||
                    mapping.iban.endsWith(identifier)) {
                return mapping;
            }
        }
        return null;
    }
}



-------------------
