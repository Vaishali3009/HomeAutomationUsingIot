package com.rbs.bdd.domain.enums;

/**
 * Enum to map known IBANs to first and last customer names.
 */
public enum CustomerNameMapping {

    IBAN_1("GB29NWBK60161331926801", "Alice", "Johnson"),
    IBAN_2("GB82WEST12345698765437", "Bob", "Williams"),
    IBAN_3("GB94BARC10201530093422", "Clara", "Brown"),
    IBAN_4("GB33BUKB20201555555567", "David", "Smith");

    private final String iban;
    private final String firstName;
    private final String lastName;

    CustomerNameMapping(String iban, String firstName, String lastName) {
        this.iban = iban;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getIban() {
        return iban;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public static CustomerNameMapping fromIdentifier(String identifier) {
        for (CustomerNameMapping mapping : values()) {
            if (mapping.iban.equals(identifier) ||
                mapping.iban.endsWith(identifier)) {
                return mapping;
            }
        }
        return null;
    }
}

------

package com.rbs.bdd.application.service;

import com.rbs.bdd.application.exception.AccountValidationException;
import com.rbs.bdd.application.port.out.RetrieveCustomerPort;
import com.rbs.bdd.common.ErrorConstants;
import com.rbs.bdd.common.ServiceConstants;
import com.rbs.bdd.domain.enums.CustomerNameMapping;
import com.rbs.bdd.domain.enums.model.ErrorDetail;
import com.rbsg.soa.c040paymentmanagement.customerretrievalforpayment.v01.serviceparameters.v01.RetrievePrimaryCustomerForArrRequest;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.ws.WebServiceMessage;
import org.springframework.ws.soap.saaj.SaajSoapMessage;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.Optional;
import java.util.UUID;

import static com.rbs.bdd.common.ServiceConstants.INTL_BANK_ACCOUNT;
import static com.rbs.bdd.common.ServiceConstants.UK_BASIC_BANK_ACCOUNT;

/**
 * Service to handle logic for retrieving customer details based on account number.
 * Matches specific identifiers and dynamically updates SOAP XML response.
 */
@Service
@RequiredArgsConstructor
public class CustomerRetrievalService implements RetrieveCustomerPort {

    private static final Logger logger = LoggerFactory.getLogger(CustomerRetrievalService.class);
    private static final String STATIC_RESPONSE_PATH = "static-response/customer-retrieval/success-response.xml";

    @Override
    public void validateSchema(RetrievePrimaryCustomerForArrRequest request) {
        logger.info("Schema validated successfully by Spring WS.");
    }

    @Override
    public void retrieveCustomer(RetrievePrimaryCustomerForArrRequest request, WebServiceMessage message) {
        try {
            RequestParams params = extractParams(request);
            XPath xpath = XPathFactory.newInstance().newXPath();
            Document responseDoc;

            Optional<ErrorDetail> error = determineError(params);
            if (error.isPresent()) {
                responseDoc = loadAndParseXml(ServiceConstants.ERROR_XML_PATH);
                applyErrorResponse(responseDoc, xpath, error.get(), params.originalTxnId());
            } else {
                CustomerNameMapping matched = CustomerNameMapping.fromIdentifier(params.identifier);
                if (matched != null) {
                    responseDoc = loadAndParseXml(STATIC_RESPONSE_PATH);
                    updateName(responseDoc, xpath, matched.getFirstName(), matched.getLastName());
                    logger.info("Returning matched customer response for IBAN: {}", matched.getIban());
                } else {
                    responseDoc = loadAndParseXml(ServiceConstants.ERROR_XML_PATH);
                    applyErrorResponse(responseDoc, xpath, ErrorConstants.ERR_MOD97_IBAN, params.originalTxnId);
                }
            }

            ByteArrayOutputStream out = new ByteArrayOutputStream();
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.transform(new DOMSource(responseDoc), new StreamResult(out));

            ((SaajSoapMessage) message).getSaajMessage().getSOAPPart()
                    .setContent(new StreamSource(new ByteArrayInputStream(out.toByteArray())));

        } catch (Exception e) {
            logger.error("Customer retrieval failed", e);
            throw new RuntimeException("Customer retrieval failed", e);
        }
    }

    private void updateName(Document doc, XPath xpath, String firstName, String lastName) throws XPathExpressionException {
        updateText(xpath, doc, "//crfpTO:firstName", firstName);
        updateText(xpath, doc, "//crfpTO:lastName", lastName);
    }

    private Optional<ErrorDetail> determineError(RequestParams p) {
        if (INTL_BANK_ACCOUNT.equals(p.codeValue)) {
            if (!p.identifier.startsWith("GB")) return Optional.of(ErrorConstants.ERR_WRONG_COUNTRY_CODE);
            if (p.length != 22) return Optional.of(ErrorConstants.ERR_INVALID_IBAN_LENGTH);
        } else if (UK_BASIC_BANK_ACCOUNT.equals(p.codeValue)) {
            if (p.identifier.startsWith("GB")) return Optional.of(ErrorConstants.ERR_DB2_SQL);
            if (p.length != 14) return Optional.of(ErrorConstants.ERR_INVALID_UBAN_LENGTH);
        }
        return Optional.empty();
    }

    private void applyErrorResponse(Document doc, XPath xpath, ErrorDetail detail, String txnId) throws XPathExpressionException {
        updateText(xpath, doc, ErrorConstants.XPATH_RESPONSE_ID_TXN_ID, generateTxnId());
        updateText(xpath, doc, ErrorConstants.XPATH_REF_REQUEST_TXN_ID, txnId);
        updateText(xpath, doc, ErrorConstants.XPATH_CMD_STATUS, "Failed");
        updateText(xpath, doc, ErrorConstants.XPATH_CMD_DESCRIPTION, detail.description);
        updateText(xpath, doc, ErrorConstants.XPATH_TIMESTAMP, ZonedDateTime.now().toString());
        updateText(xpath, doc, ErrorConstants.XPATH_RETURN_CODE, detail.returnCode);

        if (detail.systemNotificationDesc != null) {
            updateText(xpath, doc, ErrorConstants.XPATH_SYS_NOTIFICATION_DESC, detail.systemNotificationDesc);
            updateText(xpath, doc, ErrorConstants.XPATH_SYS_NOTIFICATION_CODE, detail.returnCode);
        } else {
            Node node = (Node) xpath.evaluate(ErrorConstants.XPATH_SYS_NOTIFICATION_BLOCK, doc, XPathConstants.NODE);
            if (node != null) node.getParentNode().removeChild(node);
        }
    }

    private void updateText(XPath xpath, Document doc, String path, String value) throws XPathExpressionException {
        Node node = (Node) xpath.evaluate(path, doc, XPathConstants.NODE);
        if (node != null && value != null) node.setTextContent(value);
    }

    private Document loadAndParseXml(String path) throws Exception {
        InputStream stream = getClass().getClassLoader().getResourceAsStream(path);
        if (stream == null) throw new AccountValidationException("XML not found: " + path);

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(stream);
    }

    private RequestParams extractParams(RetrievePrimaryCustomerForArrRequest request) {
        return new RequestParams(
                request.getArrangementIdentifier().getIdentifier(),
                request.getArrangementIdentifier().getContext().getCodeValue(),
                request.getArrangementIdentifier().getIdentifier().length(),
                request.getRequestHeader().getRequestIds().get(0).getTransactionId(),
                request.getRequestHeader().getRequestIds().get(0).getSystemId()
        );
    }

    private String generateTxnId() {
        return "1alN" + UUID.randomUUID().toString().replace("-", "") + "h";
    }

    private record RequestParams(String identifier, String codeValue, int length, String originalTxnId, String systemId) {}
}
